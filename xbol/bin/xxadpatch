#!/usr/bin/perl -w
# +=======================================================================+
# |          Copyright (c) 2004 Oracle Argentina, Buenos Aires            |
# |                         All rights reserved.                          |
# +=======================================================================+
# | FILENAME                                                              |
# |    xxadpatch                                                          |
# |                                                                       |
# | DESCRIPTION                                                           |
# |    Script de instalacion de patches                                   |
# |                                                                       |
# | VERSION                                                               |
# |    4.0                                                                |
# |                                                                       |
# | HISTORY                                                               |
# |    06-JUL-2004    GMartino    Creado                                  |
# |    17-NOV-2004    GMartino    Liberada v1.3                           |
# |    15-JUN-2005    GMartino    Liberada v2.0                           |
# |    15-FEB-2006    FBarros   Pasada a Perl                             |
# |    20-DIC-2008    FBarros   Ejecucion comandos Java                   |
# |    12-ENE-2009    FBarros   Modificacion ejecucion Java               |
# |    12-SEP-2009    FBarros   Se elimina la utilizacion de la clase     |
# |                             XXValidatorCommand                        |
# |    18-MAR-2010    FBarros   Se agrega la funcion de Validacion de     |
# |                             re-instalacion de parches                 |
# |                             Tambien se agregan los segundos en el     |
# |                             archivo de backup que se genera al        |
# |                             realizar la copia de objetos              |
# |                                                                       |
# +=======================================================================+



# ------------------------------------------------------------------------
# Definicion de variables de entorno genericas
# ------------------------------------------------------------------------
$L_PROGRAM_NAME="xxadpatch";
$EXIT_CODE_OK=0;
$EXIT_CODE_ERROR=1;

$ARGUMENT_ERROR_FLAG="N";
%LIST_OF_VIRTUAL_USERS=();


# ------------------------------------------------------------------------
# Definicion de variables para el usuario y tabla de log por defecto
# ------------------------------------------------------------------------
$DEFAULT_DB_USER="APPS";
$DEFAULT_DB_PWD="";
$DEFAULT_LOG_TABLE_NAME="XX_AD_APPLIED_PATCHES";


# ---------------------------------------------------------------------- #
#                                                                        #
#                  P R O G R A M A    P R I N C I P A L                  #
#                                                                        #
# ---------------------------------------------------------------------- #


# ------------------------------------------------------------------------
#
# PASO 1:
# OBTENCION Y VALIDACION DE LOS ARGUMENTOS
# Recuperacion y validacion de cada uno de los argumentos recibidos
# como parametro
#
# ------------------------------------------------------------------------


$i = 0;

# --------------------------------------------------------------------------
# Recupero los argumentos recibidos como parametro
# --------------------------------------------------------------------------
while ( $ARGV[$i] ) {

   if ($ARGV[$i] eq "-h")  {
      ShowUsage();
      exit $EXIT_CODE_OK;
   } elsif  ($ARGV[$i] eq "-b") {
      if ( ! $DRIVERFILE ) {
         $BACKUP_FLAG="Y"
      } else {
         $ARGUMENT_ERROR_FLAG="Y"
      }
      $i++;
   } elsif ($ARGV[$i] eq "-B") {
       if ( ! $DRIVERFILE ) {
          $BACKUP_FLAG="N"
       }  else {
          $ARGUMENT_ERROR_FLAG="Y"
       }
       $i++;
   } elsif ($ARGV[$i] eq "-l") {
      if ( ! $DRIVERFILE) {
         $LOGFILE=$ARGV[$i+1];
      } else {
         $ARGUMENT_ERROR_FLAG="Y";
      }
      $i = $i + 2;

   } elsif ($ARGV[$i] eq "-t" ) {
      if ( ! $DRIVERFILE ) {
         $TMP_DIR=$ARGV[$i+1];
      } else {
         $ARGUMENT_ERROR_FLAG="Y";
      }
      $i = $i + 2;

   } elsif ($ARGV[$i] eq "-v" ) {
      if ( $DRIVERFILE ) {

         $ARGUMENT_ERROR_FLAG="Y";
         $i = $i + 2;

      } else {

         $XX_VIRTUAL_USER_NAME="$ARGV[$i+1]";
         $XX_VIRTUAL_USER_NAME=~s/=.*//;
         $XX_REAL_USER_NAME="$ARGV[$i+1]";
         $XX_REAL_USER_NAME=~s/.*=//;

         if ( ! $XX_VIRTUAL_USER_NAME ) {
            $ARGUMENT_ERROR_FLAG="Y";
            $i = $i + 2;
         } elsif ( ! $XX_REAL_USER_NAME ) {
            $ARGUMENT_ERROR_FLAG="Y";
            $i = $i + 2;
         } elsif ( $XX_VIRTUAL_USER_NAME eq $ARGV[$i+1] ) {
            $ARGUMENT_ERROR_FLAG="Y";
            $i = $i + 2;
         } else {
            $XX_VIRTUAL_USER_NAME=~tr/a-z/A-Z/;
            $XX_REAL_USER_NAME=~tr/a-z/A-Z/;
            $LIST_OF_VIRTUAL_USERS{$XX_VIRTUAL_USER_NAME}=$XX_REAL_USER_NAME;

            $i = $i + 2;
         }
     }
   } else {

      if ( ! $DRIVERFILE ) {
         $DRIVERFILE = $ARGV[$i];
      } else {

         $ARGUMENT_ERROR_FLAG="Y";
      }
      $i++;
   }
}


# ------------------------------------------------------------------------
# Verifico que los argumentos pasados sean correctos
# ------------------------------------------------------------------------
if ( $ARGUMENT_ERROR_FLAG eq "Y" ) {
   print "$L_PROGRAM_NAME: ERROR: Los argumentos recibidos son invalidos.\n";
   ShowUsage ();
   exit $EXIT_CODE_ERROR;
}


# ------------------------------------------------------------------------
# PARAMETRO: DRIVER FILE NAME
# Definicion y verificacion del nombre del archivo driver
# ------------------------------------------------------------------------
if ( ! $DRIVERFILE ) {
    print "$L_PROGRAM_NAME: ERROR: No se especifico el driver de instalacion.\n";
    ShowUsage();
    exit $EXIT_CODE_ERROR;
}

if ( ! -f $DRIVERFILE ) {
    print "$L_PROGRAM_NAME: ERROR: No se encontro el driver de instalacion indicado ($DRIVERFILE).\n";
    ShowUsage();
    exit $EXIT_CODE_ERROR;
}



# ------------------------------------------------------------------------
# PARAMETRO: LOG FILE NAME
# Definicion del archivo para logs
# ------------------------------------------------------------------------
if ( ! $LOGFILE ) {
    $LOGFILE=$DRIVERFILE;
    $LOGFILE=~s/\.drv/\.log/;
}

if ( ! -f $LOGFILE ) {
    open (LOGFH, ">$LOGFILE") || die "ERROR: No se pudo crear el archivo de log\n Archivo Log: $LOGFILE\n";
} else {
    open (LOGFH, ">>$LOGFILE") || die "ERROR: No se pudo crear el archivo de log\n Archivo Log: $LOGFILE\n";
}

# ------------------------------------------------------------------------
# PARAMETRO: BACKUP FLAG
# Definicion del indicador para hacer respaldo de los fuentes o no
# ------------------------------------------------------------------------
if ( ! $BACKUP_FLAG ) {
    $BACKUP_FLAG="Y";
}



# ------------------------------------------------------------------------
# PARAMETRO: TEMPORARY DIRECTORY
# Definicion del directorio para almacenar los archivos temporales
# ------------------------------------------------------------------------
if ( ! $TMP_DIR ) {
    if ( $ENV{"APPLTMP"} ) {
        $TMP_DIR=$ENV{"APPLTMP"};
        if ( ! -d $TMP_DIR ) {
            $TMP_DIR="/tmp";
        }
    } else {
        $TMP_DIR="/tmp";
    }
}

if ( ! -d $TMP_DIR ) {
    print "ERROR: No se pudo definir el directorio temporal\n";
    print "Directorio: $TMP_DIR\n";
    exit $EXIT_CODE_ERROR;
}
$TMPFILE="$TMP_DIR/$L_PROGRAM_NAME";
open (TMPFH, "> $TMPFILE.$$") || die "Error al abrir archivo temporal $TMPFILE\n" ;




# ------------------------------------------------------------------------
# Imprimo encabezado en el log del proceso
# ------------------------------------------------------------------------
$PATCHSTARTDATE=`date`;
#
print LOGFH (" \n");
print LOGFH ("--------------------------------------------------\n");
print LOGFH (" \n");
print LOGFH (" INICIANDO APLICACION DE PATCH \n");
print LOGFH (" Archivo Driver : $DRIVERFILE \n");
print LOGFH (" Fecha Inicio   : $PATCHSTARTDATE \n");
print LOGFH (" Archivo Log    : $LOGFILE \n");
print LOGFH (" Respaldo Activo: $BACKUP_FLAG \n");
print LOGFH (" Dir Temporal   : $TMP_DIR \n");
print LOGFH (" \n");
print LOGFH ("--------------------------------------------------\n");
print LOGFH (" \n");
print LOGFH (" \n");


# ------------------------------------------------------------------------
#
# PASO 2:
# VALIDACIONES SINTACTICAS
# Hago una primer recorrida sobre el archivo driver para validar la
# sintaxis de los comandos contenidos
#
# ------------------------------------------------------------------------




# ------------------------------------------------------------------------
# Valido la sintaxis de los comandos del driver
# ------------------------------------------------------------------------
              #
              # Inicializo las variables
              #
              $abortflag="N";
              $errorcode="ERROR: Error de sintaxis en linea ";
              $errormsg="El driver no pudo ser ejecutado.";

              #
              # Variables para comandos begin/end patch
              #
              $beginend_patch_within="N";
              $beginend_patch_count=0;
              $beginend_patch_last="";
              $beginend_patch_commands_out=0;

              #
              # Variables para comandos begin/end patch_info
              #
              $beginend_patch_info_within="N";
              $beginend_patch_info_count=0;

              #
              # Variables para comandos begin/end log_info
              #
              $beginend_log_info_within="N";
              $beginend_log_info_count=0;
              $beginend_log_info_conn="";
              #
              # Variables para comandos begin/end prereq
              #
              $beginend_prereq_within="N";
              $beginend_prereq_last="";

              #
              # Variables para comandos begin/end connection
              #
              $beginend_conn_within="N";
              $beginend_conn_last="";

   $NR = 0;
   open (DF, $DRIVERFILE) || die "Error al abrir el archivo $DRIVERFILE\n";
   while (defined ($line = <DF>)) {
      chomp ($line);
      # Eliminar Blancos al principio de la linea
      $line=~s/^ *//;

      # dividir la linea en campos de un vector separador=" "
      @vline = split /\s+/ , $line;
      $NF = @vline;
      $NR++;


#     print "DEBUG Cantidad de elementos leidos $NF\n";
#     print "DEBUG numero de linea $.\n";
#     print "DEBUG Primer elemento $vline[0]\n";
#     print "DEBUG Segundo elemento $vline[1]\n";
#     print "DEBUG Tercer elemento $vline[2]\n";

      if ($NF) {
               #
               # Verifico si los comandos del driver son validos
               #
                   if ( ! ($vline[0] eq "copy" ||
                           $vline[0] eq "mergepll" ||
                           $vline[0] eq "purgepll" ||
                           $vline[0] eq "sql" ||
                           $vline[0] eq "exec" ||
                           $vline[0] eq "java" ||
                           $vline[0] eq "javac" ||
                           $vline[0] eq "genform" ||
                           $vline[0] eq "genfpll" ||
                           $vline[0] eq "release" ||
                           $vline[0] eq "server" ||
                           $vline[0] eq "language" ||
                           $vline[0] eq "table" ||
                          ($vline[0] eq "begin" && $vline[1] eq "patch") ||
                          ($vline[0] eq "end"   && $vline[1] eq "patch") ||
                          ($vline[0] eq "begin" && $vline[1] eq "patch_info") ||
                          ($vline[0] eq "end"   && $vline[1] eq "patch_info") ||
                          ($vline[0] eq "begin" && $vline[1] eq "log_info") ||
                          ($vline[0] eq "end"   && $vline[1] eq "log_info") ||
                          ($vline[0] eq "begin" && $vline[1] eq "connection") ||
                          ($vline[0] eq "end"   && $vline[1] eq "connection") ||
                          ($vline[0] eq "begin" && $vline[1] eq "prereq") ||
                          ($vline[0] eq "end"   && $vline[1] eq "prereq") ||
                           substr($vline[0], 0, 1) eq "#")) {
                       print "$errorcode $NR\n";
                       print "Comando $vline[0] no reconocido\n";
                       print "$errormsg \n";
                       $abortflag="Y";
                       exit $EXIT_CODE_ERROR;
                   }

               #
               # Verifico la sintaxis del comando "begin patch"
               #
               if ($vline[0] eq "begin" && $vline[1] eq "patch") {
                   if ($beginend_patch_within eq "Y") {
                       print "$errorcode $NR\n";
                       print "No es posible definir comandos \"begin patch\"" ;
                       print " anidados.\n";
                       print "$errormsg \n";
                       $abortflag="Y";
                       exit $EXIT_CODE_ERROR;
                   }
                   $beginend_patch_within="Y";
                   $beginend_patch_count++;
                   if ($NF != 3) {
                       print "$errorcode $NR\n";
                       print "Argumentos invalidos para el comando \"begin patch\"\n";
                       print "$errormsg \n";
                       $abortflag="Y";
                       exit $EXIT_CODE_ERROR;
                   }
                   $beginend_patch_last=$vline[2];
                   if ($beginend_patch_count > 1) {
                       print "$errorcode $NR\n";
                       print "Solo puede definirse un unico bloque " ;
                       print "\"begin/end patch\" por driver\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit $EXIT_CODE_ERROR;
                   }
               }

               #
               # Verifico la sintaxis del comando "end patch"
               #
               if ($vline[0] eq "end" && $vline[1] eq "patch") {
                   $beginend_patch_within="N";
                   if ($NF != 3) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"end patch\"";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($vline[2] ne $beginend_patch_last) {
                       print "$errorcode $NR \n";
                       print "El nombre especificado en el comando" ;
                       print     " \"end patch\" no coincide con el " ;
                       print     "indicado en el comando \"begin\"\\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }

               #
               # Verifico la sintaxis del comando "begin patch_info"
               #
               if ($vline[0] eq "begin" && $vline[1] eq "patch_info") {
                   if ($beginend_patch_info_within eq "Y") {
                       print "$errorcode $NR \n";
                       print "No es posible definir comandos \"begin " ;
                       print     "patch_info\" anidados.\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N" ||
                       $beginend_log_info_within eq "Y" ||
                       $beginend_prereq_within eq "Y" ||
                       $beginend_conn_within eq "Y") {
                       print "$errorcode $NR \n";
                       print "El comando \"begin patch_info\" siempre debe " ;
                       print     "estar contenido dentro de un bloque \"begin/" ;
                       print     "end patch\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   $beginend_patch_info_within="Y";
                   $beginend_patch_info_count++;
                   if ($NF != 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"begin patch_info\"";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_info_count > 1) {
                       print "$errorcode $NR \n";
                       print "Solo puede definirse un unico bloque " ;
                       print     "\"begin/end patch_info\" por patch";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico la sintaxis del comando "end patch_info"
               #
               if ($vline[0] eq "end" && $vline[1] eq "patch_info") {
                   $beginend_patch_info_within="N";
                   if ($beginend_patch_within eq "N") {
                       print "$errorcode $NR \n";
                       print "El comando \"begin patch_info\" siempre debe " ;
                       print     "estar contenido dentro de un bloque \"begin/" ;
                       print     "end patch\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($NF != 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"end patch_info\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico la sintaxis del comando "begin log_info"
               #

               if ($vline[0] eq "begin" && $vline[1] eq "log_info") {
                   if ($beginend_log_info_within eq "Y") {
                       print "$errorcode $NR \n";
                       print "No es posible definir comandos \"begin " ;
                       print     "log_info\" anidados.\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N" ||
                       $beginend_patch_info_within eq "Y" ||
                       $beginend_prereq_within eq "Y") {
                       print "$errorcode $NR \n";
                       print "El comando \"begin log_info\" siempre debe " ;
                       print     "estar contenido dentro de un bloque \"begin/" ;
                       print     "end patch\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_conn_within eq "Y") {
                       $beginend_log_info_conn=beginend_conn_last;
                   } else {
                       $beginend_log_info_conn="";
                   }
                   $beginend_log_info_within="Y";
                   $beginend_log_info_count++;
                   if ($NF != 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"begin log_info\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_log_info_count > 1) {
                       print "$errorcode $NR \n";
                       print "Solo puede definirse un unico bloque " ;
                       print     "\"begin/end log_info\" por patch\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico la sintaxis del comando "end log_info"
               #
               if ($vline[0] eq "end" && $vline[1] eq "log_info") {
                   $beginend_log_info_within="N";
                   if ($beginend_patch_within eq "N") {
                       print "$errorcode $NR \n";
                       print "El comando \"begin patch_info\" siempre debe " ;
                       print     "estar contenido dentro de un bloque \"begin/" ;
                       print     "end patch\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   $beginend_log_info_conn="";
                   if ($NF != 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"end log_info\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico la sintaxis del comando "begin prereq"
               #
               if ($vline[0] eq "begin" && $vline[1] eq "prereq") {
                   if ($beginend_prereq_within eq "Y") {
                       print "$errorcode $NR \n";
                       print "No es posible definir comandos \"begin " ;
                       print     "prereq\" anidados.\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N" ||
                       $beginend_patch_info_within eq "Y" ||
                       $beginend_log_info_within eq "Y" ||
                       $beginend_conn_within eq "Y") {
                       print "$errorcode $NR \n";
                       print "El comando \"begin prereq\" siempre debe " ;
                       print     "estar contenido dentro de un bloque \"begin/" ;
                       print     "end patch\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   $beginend_prereq_within="Y";
                   if ($NF != 3) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"begin prereq\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   $beginend_prereq_last=$vline[2];
               }
               #
               # Verifico la sintaxis del comando "end prereq"
               #
               if ($vline[0] eq "end" && $vline[1] eq "prereq") {
                   $beginend_prereq_within="N";
                   if ($beginend_patch_within eq "N") {
                       print "$errorcode $NR \n";
                       print "El comando \"begin prereq\" siempre debe " ;
                       print     "estar contenido dentro de un bloque \"begin/" ;
                       print     "end patch\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($NF != 3) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"end prereq\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($vline[2] ne $beginend_prereq_last) {
                       print "$errorcode $NR \n";
                       print "El nombre especificado en el comando" ;
                       print     " \"end prereq\" no coincide con el " ;
                       print     "indicado en el comando \"begin\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }

               #
               # Verifico la sintaxis del comando "begin connection"
               #
               if ($vline[0] eq "begin" && $vline[1] eq "connection") {
                   if ($beginend_conn_within eq "Y") {
                       print "$errorcode $NR \n";
                       print "No es posible definir comandos \"begin " ;
                       print     "connection\" anidados.\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N" ||
                       $beginend_patch_info_within eq "Y" ||
                       $beginend_log_info_within eq "Y" ||
                       $beginend_prereq_within eq "Y") {
                       print "$errorcode $NR \n";
                       print "El comando \"begin connection\" siempre debe " ;
                       print     "estar contenido dentro de un bloque \"begin/" ;
                       print     "end patch\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   $beginend_conn_within="Y";
                   if ($NF != 3) {
                       if ($vline[3] ne "virtual") {
                           print "$errorcode $NR \n";
                           print "Argumentos invalidos para el comando \"begin connection\"";
                           print "$errormsg\n";
                           $abortflag="Y";
                           exit "$EXIT_CODE_ERROR\n";
                       }
                   }
                   $beginend_conn_last=$vline[2];
               }
               #
               # Verifico la sintaxis del comando "end connection"
               #
               if ($vline[0] eq "end" && $vline[1] eq "connection") {
                   $beginend_conn_within="N";
                   if ($beginend_patch_within eq "N") {
                       print "$errorcode $NR \n";
                       print "El comando \"begin connection\" siempre debe " ;
                       print      "estar contenido dentro de un bloque \"begin/" ;
                       print      "end patch\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($NF != 3) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"end connection\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($vline[2] ne $beginend_conn_last) {
                       print "$errorcode $NR \n";
                       print "El nombre especificado en el comando" ;
                       print     " \"end connection\" no coincide con el " ;
                       print     "indicado en el comando \"begin\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_log_info_conn eq $beginend_conn_last) {
                       print "$errorcode $NR \n";
                       print "El comando \"end connection\" es invalido " ;
                       print     "dado que no se encontro un comando " ;
                       print     "\"end log_info\" anteriormente.\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico la sintaxis del comando "copy"
               #
               if ($vline[0] eq "copy") {
                   if ($NF != 4) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"copy\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "mergepll"
               #
               if ($vline[0] eq "mergepll") {
                   if ($NF != 4 && $NF != 5 && $NF != 6) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando" ;
                       print     " \"mergepll\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($NF eq 6 && substr($vline[4], length($vline[4])-3) ne "pll") {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando" ;
                       print     " \"mergepll\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "purgepll"
               #
               if ($vline[0] eq "purgepll") {
                   if ($NF != 5 && $NF != 6) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando" ;
                       print     " \"purgepll\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "sql"
               #
               if ($vline[0] eq "sql") {
                   if ($NF != 4) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"sql\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "exec"
               #
               if ($vline[0] eq "javac") {
                   if ($NF < 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"javac\"\n";
                       print "Ex.   javac <java class> \n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "exec"
               #
               if ($vline[0] eq "java") {
                   if ($NF < 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"java\"\n";
                       print "Ex.   java <java class> <parameters> &db_host &db_name &db_port \n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "exec"
               #
               if ($vline[0] eq "exec") {
                   if ($NF < 3) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"exec\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "genform"
               #
               if ($vline[0] eq "genform") {
                   if ($NF != 4) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"genform\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "genfpll"
               #
               if ($vline[0] eq "genfpll") {
                   if ($NF != 4) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"genfpll\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_within eq "N") {
                       $beginend_patch_commands_out++;
                   }
               }
               #
               # Verifico la sintaxis del comando "release"
               #
               if ($vline[0] eq "release") {
                   if ($NF != 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"release\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_info_within eq "N" &&
                       $beginend_prereq_within eq "N") {
                       print "$errorcode $NR \n";
                       print "El comando \"release\" debe estar siempre " ;
                       print     "contenido dentro de un bloque \"begin/end " ;
                       print     "patch_info\" o \"begin/end prereq\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico la sintaxis del comando "server"
               #
               if ($vline[0] eq "server") {
                   if ($NF != 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"server\"";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_info_within eq "N" &&
                       $beginend_prereq_within eq "N") {
                       print "$errorcode $NR \n";
                       print "El comando \"server\" debe estar siempre " ;
                       print     "contenido dentro de un bloque \"begin/end " ;
                       print     "patch_info\" o \"begin/end prereq\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico la sintaxis del comando "language"
               #
               if ($vline[0] eq "language") {
                   if ($NF != 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando " ;
                       print     "\"language\"\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_patch_info_within eq "N" &&
                       $beginend_prereq_within eq "N") {
                       print "$errorcode $NR \n";
                       print "El comando \"language\" debe estar siempre " ;
                       print     "contenido dentro de un bloque \"begin/end " ;
                       print     "patch_info\" o \"begin/end prereq\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico la sintaxis del comando "table"
               #
               if ($vline[0] eq "table") {
                   if ($NF != 2) {
                       print "$errorcode $NR \n";
                       print "Argumentos invalidos para el comando \"table\"";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
                   if ($beginend_log_info_within eq "N") {
                       print "$errorcode $NR \n";
                       print "El comando \"table\" debe estar siempre " ;
                       print     "contenido dentro de un bloque \"begin/end " ;
                       print     "log_info\".\n";
                       print "$errormsg\n";
                       $abortflag="Y";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
           }
        }
        # Cierro el File Handler del driver
        close (DF);


               #
               # Verifico que el "begin" tenga su correspondiente "end"
               #
               if ($beginend_patch_within eq "Y") {
                   if ($abortflag eq "N") {
                       print "$errorcode $NR \n";
                       print "Se encontro un comando \"begin patch\"";
                       print     " sin su correspondiente \"end\"\n";
                       print "$errormsg\n";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               if ($beginend_patch_info_within eq "Y") {
                   if ($abortflag eq "N") {
                       print "$errorcode $NR \n";
                       print "Se encontro un comando \"begin patch_info\"";
                       print     " sin su correspondiente \"end\"\n";
                       print "$errormsg\n";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               if ($beginend_log_info_within eq "Y") {
                   if ($abortflag eq "N") {
                       print "$errorcode $NR \n";
                       print "Se encontro un comando \"begin log_info\"";
                       print " sin su correspondiente \"end\"\n";
                       print "$errormsg\n";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               if ($beginend_prereq_within eq "Y") {
                   if ($abortflag eq "N") {
                       print "$errorcode $NR \n";
                       print "Se encontro un comando \"begin prereq\"";
                       print     " sin su correspondiente \"end\"\n";
                       print "$errormsg\n";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               if ($beginend_conn_within eq "Y") {
                   if ($abortflag eq "N") {
                       print "$errorcode $NR \n";
                       print "Se encontro un comando \"begin connection\"";
                       print " sin su correspondiente \"end\"\n";
                       print "$errormsg\n";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }
               #
               # Verifico que no haya comandos fuera del "begin/end"
               #
               if ($beginend_patch_count > 0 &&
                   $beginend_patch_commands_out > 0) {
                   if ($abortflag eq "N") {
                       if ($beginend_patch_commands_out eq 1) {
                           print "$errorcode $NR \n";
                           print "Existe  $beginend_patch_commands_out \n";
                           print " comando fuera del bloque \"begin/end patch\"\n";
                       } else {
                           print "$errorcode $NR \n";
                           print "Existen $beginend_patch_commands_out \n";
                           print " comandos fuera del bloque \"begin/end patch\"\n";
                       }
                       print "$errormsg\n";
                       exit "$EXIT_CODE_ERROR\n";
                   }
               }


# ------------------------------------------------------------------------
#
# PASO 3:
# GENERACION DE METASCRIPT PARA EJECUTAR LOS COMANDOS DEL DRIVER
# Genero un metascript en el directorio temporal en base a los comandos
# contenidos en el archivo driver
#
# ------------------------------------------------------------------------



# ------------------------------------------------------------------------
# Genero el encabezado del script con las rutinas a utilizar
# ------------------------------------------------------------------------

print TMPFH "#!/usr/bin/perl -w
# -------------------------------------------------------------
#
# Routine    : PrintLine
# Purpose    : Imprime un texto por pantalla y en el log
# Parameters : l_text_line : Texto a imprimir
#              l_log_file  : Archivo de log
#
# -------------------------------------------------------------
sub PrintLine {
       print \" \$TEXT_LINE \\n\";
       if (\$LOGFILE) {
          print LOGFH \" \$TEXT_LINE \\n\";
       }
}
";

print TMPFH "
# -------------------------------------------------------------
#
# Routine    : Replace_Connection
# Purpose    : Reemplaza la cadena &connection por el valor
#              ingresado durante la ejecucion
#              Por ejemplo:
#              - &connection se reemplaza <host>:<port>:<base>
#
# Parameters :
#              l_text_to_be_replaced  : Texto a ser reemplazado
#              l_connection           : Thin Connection 
# Retorna    :
#              l_text_replaced        : Texto reemplazado
#
# -------------------------------------------------------------
sub Replace_Connection  {

       \$l_text_replaced=\$XX_TEXT_TO_BE_REPLACED;

       # Replace Database HOST
       \$lreplace     =\$DB_HOST;
       \$ltoreplace   =\"&db_host\";
       \$l_text_replaced=~s/\$ltoreplace/\$lreplace/;

       # Replace Database PORT
       \$lreplace     =\$DB_PORT;
       \$ltoreplace   =\"&db_port\";
       \$l_text_replaced=~s/\$ltoreplace/\$lreplace/;

       # Replace Database NAME
       \$lreplace     =\$DB_NAME;
       \$ltoreplace   =\"&db_name\";
       \$l_text_replaced=~s/\$ltoreplace/\$lreplace/;


       return \$l_text_replaced;
}\n";

print TMPFH "
# -------------------------------------------------------------
#
# Routine    : Replace_User_Passwords
# Purpose    : Reemplaza en una cadena de caracteres, cada una
#              de las variables dinamicas por las passwords de
#              de los usuarios que correspondan.
#              Por ejemplo:
#              - &appspwd se reemplaza con la password de APPS
#              - &arpwd se reemplaza con la password de AR
#              - &xxopwd se reemplaza con la password de XXO
#              - etc.
# Parameters :
#              l_text_to_be_replaced  : Texto a ser reemplazado
#              l_list_of_db_users     : Lista de usuarios
#              l_list_of_users_pwd    : Lista de Passwords
# Retorna    :
#              l_text_replaced        : Texto reemplazado
#
# -------------------------------------------------------------
sub Replace_User_Passwords  {

       \$l_text_replaced=\$XX_TEXT_TO_BE_REPLACED;

       foreach \$xxusername (keys \%XX_LIST_OF_PASSWORDS) {

           # obtengo la password
           \$userpassword=\$XX_LIST_OF_PASSWORDS{\$xxusername};

           # paso a minusculas
           \$xxusername=~tr/A-Z/a-z/;
           \$userpassword=~tr/A-Z/a-z/;

           \$ltoreplace = sprintf(\"\&\%spwd\", \$xxusername);
           \$l_text_replaced=~s/\$ltoreplace/\$userpassword/;

       };
       return \$l_text_replaced;
}\n";

print TMPFH "
# ------------------------------------------------------------
#
# Routine    : CheckDBThinConnection
# Purpose    : Verifica la conexion con la base de datos para
#              un usuario y password dados
# Parameters : DBUSER      : Usuario de la base de datos
#              DBPASSWORD  : Contrasena del usuario
#              REQUEST_USER: Indica si el usuario debe
#                            solicitarse
# ------------------------------------------------------------
sub CheckDBThinConnection {

    \$TEXT_LINE=\"### Verificando conexion a la base de datos del usuario \$DBUSER...\";
    PrintLine();

    #--------------------------------------------
    # Solicitando  Thin DB Connection
    #--------------------------------------------
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"######################################################### \";
      PrintLine();
      \$TEXT_LINE=\"### Solicitando conexion a la base de datos           ### \";
    ();
    \$TEXT_LINE=\"######################################################### \";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    # -------------------------------------------
    # Primer intento de  solicitar Connection
    # -------------------------------------------
    print \" Por favor, ingrese Servidor de Base de Datos: \";
    # leo de pantalla
    \$DB_HOST = <STDIN>;
    chomp \$DB_HOST;

    print \" Por favor, ingrese Puerto   de Base de Datos: \";
    # leo de pantalla
    \$DB_PORT = <STDIN>;
    chomp \$DB_PORT;
    
    print \" Por favor, ingrese Nombre   de Base de Datos: \";
    # leo de pantalla
    \$DB_NAME = <STDIN>;
    chomp \$DB_NAME;

    # Valido Exista Clase Java
    # \$l_result = system(\"java oracle.apps.xbol.util.XXValidatorCommand testdb \$DB_HOST:\$DB_PORT:\$DB_NAME \$DEFAULT_DB_USER \$DEFAULT_DB_PWD 2>> \$LOGFILE \");

    \$l_result = system(\"sqlplus -s \$DBUSER/\$DBPASSWORD@\\\"\(DESCRIPTION=\(ADDRESS=\(PROTOCOL=tcp\)\(HOST=\$DB_HOST\)\(PORT=\$DB_PORT\)\)\(CONNECT_DATA=\(SID=\$DB_NAME\)\)\)\\\" > /dev/null << END_OF_SQL
        \$DBUSER/\$DBPASSWORD
        \$DBUSER/\$DBPASSWORD
        EXIT 0;
        END_OF_SQL\");


    if ( ! \$l_result ) {
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\"Conexion servidor \$DB_HOST puerto \$DB_PORT base \$DB_NAME  verificada exitosamente.\";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        return \$EXIT_CODE_OK
    } 

    # -------------------------------------------
    # Segundo intento de  solicitar Connection
    # -------------------------------------------
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"ERROR: Verificando conexion servidor \$DB_HOST puerto \$DB_PORT base \$DB_NAME.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();

    print \" Por favor, ingrese Servidor de Base de Datos: \";
    # leo de pantalla
    \$DB_HOST = <STDIN>;
    chomp \$DB_HOST;

    print \" Por favor, ingrese Puerto   de Base de Datos: \";
    # leo de pantalla
    \$DB_PORT = <STDIN>;
    chomp \$DB_PORT;

    print \" Por favor, ingrese Nombre   de Base de Datos: \";
    # leo de pantalla
    # leo de pantalla
    \$DB_NAME = <STDIN>;
    chomp \$DB_NAME;

    # Valido Exista Clase Java
    # \$l_result = system(\"java oracle.apps.xbol.util.XXValidatorCommand testdb \$DB_HOST:\$DB_PORT:\$DB_NAME \$DEFAULT_DB_USER \$DEFAULT_DB_PWD 2>> \$LOGFILE \");

    \$l_result = system(\"sqlplus -s \$DBUSER/\$DBPASSWORD@\\\"\(DESCRIPTION=\(ADDRESS=\(PROTOCOL=tcp\)\(HOST=\$DB_HOST\)\(PORT=\$DB_PORT\)\)\(CONNECT_DATA=\(SID=\$DB_NAME\)\)\)\\\" > /dev/null << END_OF_SQL
        \$DBUSER/\$DBPASSWORD
        \$DBUSER/\$DBPASSWORD
        EXIT 0;
        END_OF_SQL\");


    if ( ! \$l_result ) {
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\"Conexion servidor \$DB_HOST puerto \$DB_PORT base \$DB_NAME  verificada exitosamente.\";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        return \$EXIT_CODE_OK
    } 

    # -------------------------------------------
    # Tercer intento de  solicitar Connection
    # -------------------------------------------
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"ERROR: Verificando conexion servidor \$DB_HOST puerto \$DB_PORT base \$DB_NAME.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();

    print \" Por favor, ingrese Servidor de Base de Datos: \";
    # leo de pantalla
    \$DB_HOST = <STDIN>;
    chomp \$DB_HOST;

    print \" Por favor, ingrese Puerto   de Base de Datos: \";
    # leo de pantalla
    \$DB_PORT = <STDIN>;
    chomp \$DB_PORT;

    print \" Por favor, ingrese Nombre   de Base de Datos: \";
    # leo de pantalla
    \$DB_NAME = <STDIN>;
    chomp \$DB_NAME;

    # Valido Exista Clase Java
    # \$l_result = system(\"java oracle.apps.xbol.util.XXValidatorCommand testdb \$DB_HOST:\$DB_PORT:\$DB_NAME \$DEFAULT_DB_USER \$DEFAULT_DB_PWD 2>> \$LOGFILE \");

    \$l_result = system(\"sqlplus -s \$DBUSER/\$DBPASSWORD@\\\"\(DESCRIPTION=\(ADDRESS=\(PROTOCOL=tcp\)\(HOST=\$DB_HOST\)\(PORT=\$DB_PORT\)\)\(CONNECT_DATA=\(SID=\$DB_NAME\)\)\)\\\" > /dev/null << END_OF_SQL
        \$DBUSER/\$DBPASSWORD
        \$DBUSER/\$DBPASSWORD
        EXIT 0;
        END_OF_SQL\");


    if ( ! \$l_result ) {
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\"Conexion servidor \$DB_HOST puerto \$DB_PORT base \$DB_NAME  verificada exitosamente.\";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        return \$EXIT_CODE_OK
    } else {
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\"ERROR: combinacion servidor, puerto y base  invalidos.\";
        PrintLine();
        \$TEXT_LINE=\"Numero de intentos de conexion excedido.\";
        PrintLine();
        return \$EXIT_CODE_ERROR;
    }



}\n";

print TMPFH "
# ------------------------------------------------------------
#
# Routine    : CheckDBConnection
# Purpose    : Verifica la conexion con la base de datos para
#              un usuario y password dados
# Parameters : DBUSER      : Usuario de la base de datos
#              DBPASSWORD  : Contrasena del usuario
#              REQUEST_USER: Indica si el usuario debe
#                            solicitarse
# ------------------------------------------------------------
sub CheckDBConnection {

    \$TEXT_LINE=\"### Verificando conexion a la base de datos del usuario \$DBUSER...\";
    PrintLine();

    if ( ! \$DBUSER ) {
        \$TEXT_LINE=\"ERROR: El nombre del usuario de base es nulo.\";
        PrintLine();
        return \$EXIT_CODE_ERROR;
    }

    # Lleno hash con lista de Usuarios reales y virtuales
    # y su real .
    # su contenido va a ser APPS = APPS , TAB_USER=BOLINF,PKG_USER=APPS
    \$XX_LIST_OF_REAL_USERS{\$DBUSER\}=\$DBUSER;

    \$REAL_VIRTUAL_DBUSER = \$DBUSER;
    # ---------------------------------------------------------
    # Verifico si es necesario solicitar el nombre del usuario
    # ---------------------------------------------------------
    if ( \$REQUEST_USER ) {
        if ( \$REQUEST_USER eq \"Y\" ) {

            \$TEXT_LINE=\"Ingrese el nombre del usuario VIRTUAL \$DBUSER:\";
            PrintLine();
            # leo de pantalla
            \$DBUSER = <STDIN>;
            chomp \$DBUSER;
            # Lleno hash con lista de Usuarios reales y virtuales
            \$DBUSER =~ tr/a-z/A-Z/;
            \$XX_LIST_OF_REAL_USERS{\$REAL_VIRTUAL_DBUSER\}=\$DBUSER;
        }
    }

    # --------------------------------------------------
    # Si ya existe en el hash de PWDs se da por valida
    # --------------------------------------------------
    if (\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\$REAL_VIRTUAL_DBUSER}}) {
        \$DBPASSWORD = \$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\$REAL_VIRTUAL_DBUSER}};
        \$TEXT_LINE=\"Conexion del usuario \$DBUSER verificada exitosamente.\";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        return \$EXIT_CODE_OK;
    }

    # -------------------------------------------
    # Primer intento de verificacion de password
    # -------------------------------------------
    if ( ! \$DBPASSWORD ) {
        \$TEXT_LINE=\"Por favor, ingrese la password del usuario \$DBUSER:\";
        PrintLine();
        # leo de pantalla
        \$DBPASSWORD = <STDIN>;
        chomp \$DBPASSWORD;
    }

    \$l_result = system(\"sqlplus -s \$DBUSER/\$DBPASSWORD > /dev/null << END_OF_SQL
        \$DBUSER/\$DBPASSWORD
        \$DBUSER/\$DBPASSWORD
        EXIT 0;
        END_OF_SQL\");

    if ( ! \$l_result ) {
        \$TEXT_LINE=\"Conexion del usuario \$DBUSER verificada exitosamente.\";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        return \$EXIT_CODE_OK;
    }


    # --------------------------------------------
    # Segundo intento de verificacion de password
    # --------------------------------------------
    \$TEXT_LINE=\"ERROR: Usuario y password invalidos.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"Por favor, ingrese la password del usuario \$DBUSER:\";
    PrintLine();
    # leo de pantalla
    \$DBPASSWORD = <STDIN>;
    chomp \$DBPASSWORD;
    \$l_result = system(\"sqlplus -s \$DBUSER/\$DBPASSWORD > /dev/null << END_OF_SQL
        \$DBUSER/\$DBPASSWORD
        \$DBUSER/\$DBPASSWORD
        EXIT 0;
        END_OF_SQL\");

    if ( ! \$l_result ) {
        \$TEXT_LINE=\"Conexion del usuario \$DBUSER verificada exitosamente.\";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
    return \$EXIT_CODE_OK
    }


# -------------------------------------------
# Tercer intento de verificacion de password
# -------------------------------------------
    \$TEXT_LINE=\"ERROR: Usuario y password invalidos.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"Por favor, ingrese la password del usuario \$DBUSER:\";
    PrintLine();
    # leo de pantalla
    \$DBPASSWORD = <STDIN>;
    chomp \$DBPASSWORD;

    \$l_result = system(\"sqlplus -s \$DBUSER/\$DBPASSWORD > /dev/null << END_OF_SQL
        \$DBUSER/\$DBPASSWORD
        \$DBUSER/\$DBPASSWORD
        EXIT 0;
        END_OF_SQL\");

    if ( ! \$l_result ) {
        \$TEXT_LINE=\"Conexion del usuario \$DBUSER verificada exitosamente.\";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        \$TEXT_LINE=\" \";
        PrintLine();
        return \$EXIT_CODE_OK
    } else {
        \$TEXT_LINE=\"ERROR: Usuario y password invalidos.\";
        PrintLine();
        \$TEXT_LINE=\"Numero de intentos de conexion excedido.\";
        PrintLine();
        return \$EXIT_CODE_ERROR;
    }
}\n";



print TMPFH "
# --------------------------------------------------------------
#
# Routine    : CheckLogTable
# Purpose    : Verifica si existe la tabla de log. Sino la crea
# Parameters : XXDBLOG_TABLE_DB_USR : Usuario dueno de la tabla
#              XXDBLOG_TABLE_DB_PWD : Password del usuario dueno
#              XXDBLOG_TABLE_NAME   : Nombre de la tabla de log
#
# --------------------------------------------------------------
sub CheckLogTable() {

  # Imprimo mensaje de informacion
  \$TEXT_LINE=\" \";
  PrintLine();
  \$TEXT_LINE=\"### Verificando tabla de log del proceso ...\";
  PrintLine();

# Verifico tabla de log
  \$l_result = system(\"sqlplus -s \$XXDBLOG_TABLE_DB_USR/\$XXDBLOG_TABLE_DB_PWD > /dev/null << END_OF_SQL

VARIABLE v_return_status NUMBER;

DECLARE
    ----------------------
    -- Constantes locales
    ----------------------
    C_EXIT_CODE_OK      CONSTANT INTEGER := 0;
    C_EXIT_CODE_ERROR   CONSTANT INTEGER := 1;
    ----------------------------------------------------------
    -- Variables para informacion de objetos de base de datos
    ----------------------------------------------------------
    C_TABLE_NAME        VARCHAR2(250);
    C_TABLE_OWNER       VARCHAR2(30);
    C_SYNONYM_OWNER     VARCHAR2(30);
    C_TABLE_TABLESPACE  VARCHAR2(250);
    C_INDEX_TABLESPACE  VARCHAR2(250);
    ---------------------
    -- Variables locales
    ---------------------
    l_dummy NUMBER;
    l_stm   VARCHAR2(2000);

FUNCTION Exists_Tablespace (p_tablespace_name IN VARCHAR2)
                            RETURN BOOLEAN
IS
    l_dummy NUMBER;
BEGIN
    SELECT 1
    INTO   l_dummy
    FROM   user_tablespaces
    WHERE  tablespace_name = upper(p_tablespace_name);
    RETURN TRUE;
EXCEPTION
    WHEN others THEN
        RETURN FALSE;
END Exists_Tablespace;

FUNCTION Get_Default_Tablespace (p_username IN VARCHAR2)
                                 RETURN VARCHAR2
IS
    l_tablespace  VARCHAR2(250);
BEGIN
    SELECT default_tablespace
    INTO   l_tablespace
    FROM   user_users
    WHERE  username = upper(p_username);
    RETURN l_tablespace;
EXCEPTION
    WHEN others THEN
        RETURN null;
END Get_Default_Tablespace;

BEGIN
    -----------------------------------
    -- Inicializo el codigo de retorno
    -----------------------------------
    :v_return_status := C_EXIT_CODE_OK;

    --------------------------------------------------
    -- Obtengo los datos del usuario de base de datos
    -- y del nombre de la tabla de log
    --------------------------------------------------
    C_TABLE_NAME    := upper('\$XXDBLOG_TABLE_NAME');
    C_TABLE_OWNER   := upper('\$XXDBLOG_TABLE_DB_USR');
    IF (C_TABLE_OWNER = 'APPS') THEN
        C_TABLE_OWNER   := 'APPLSYS';
        C_SYNONYM_OWNER := 'APPS';
    END IF;

    -----------------------------------------------------
    -- Obtengo los nombres de los tablespaces a utilizar
    -----------------------------------------------------
    C_TABLE_TABLESPACE := C_TABLE_OWNER || 'D';
    C_INDEX_TABLESPACE := C_TABLE_OWNER || 'X';
    IF (NOT Exists_Tablespace(C_TABLE_TABLESPACE)) THEN
        C_TABLE_TABLESPACE := 'APPS_TS_TX_DATA';
        IF (NOT Exists_Tablespace(C_TABLE_TABLESPACE)) THEN
            C_TABLE_TABLESPACE := Get_Default_Tablespace(C_TABLE_OWNER);
        END IF;
    END IF;
    IF (NOT Exists_Tablespace(C_INDEX_TABLESPACE)) THEN
        C_INDEX_TABLESPACE := 'APPS_TS_TX_IDX';
        IF (NOT Exists_Tablespace(C_INDEX_TABLESPACE)) THEN
            C_INDEX_TABLESPACE := Get_Default_Tablespace(C_TABLE_OWNER);
        END IF;
    END IF;

    ------------------------
    -- Creacion de la tabla
    ------------------------
    BEGIN
        SELECT 1
        INTO   l_dummy
        FROM   all_objects
        WHERE  owner = C_TABLE_OWNER
        AND    object_type = 'TABLE'
        AND    object_name = C_TABLE_NAME;
    EXCEPTION
        WHEN no_data_found THEN
            l_stm := 'CREATE TABLE ' || C_TABLE_OWNER || '.'
                                     || C_TABLE_NAME  || ' ( ' ||
                     'patch_name          VARCHAR2(240) NOT NULL, ' ||
                     'patch_date          DATE          NOT NULL, ' ||
                     'patch_release       VARCHAR2(240), ' ||
                     'patch_server        VARCHAR2(240), ' ||
                     'language            VARCHAR2(240), ' ||
                     'status              VARCHAR2(30)  NOT NULL, ' ||
                     'driver_name         VARCHAR2(240) NOT NULL, ' ||
                     'log_file_name       VARCHAR2(240) NOT NULL, ' ||
                     'server_name         VARCHAR2(240), ' ||
                     'directory_name      VARCHAR2(240), ' ||
                     'user_name           VARCHAR2(240), ' ||
                     'error_count         NUMBER        NOT NULL) ' ||
                     'TABLESPACE ' || C_TABLE_TABLESPACE;
            EXECUTE IMMEDIATE l_stm;
    END;
    ---------------------------
    -- Creacion de los indices
    ---------------------------
    BEGIN
        SELECT 1
        INTO   l_dummy
        FROM   all_objects
        WHERE  owner = C_TABLE_OWNER
        AND    object_type = 'INDEX'
        AND    object_name = C_TABLE_NAME || '_N1';
    EXCEPTION
        WHEN no_data_found THEN
            l_stm := 'CREATE INDEX ' || C_TABLE_OWNER || '.'
                                     || C_TABLE_NAME  || '_N1 ' ||
                     '          ON ' || C_TABLE_OWNER || '.'
                                     || C_TABLE_NAME  ||
                     '(driver_name) ' ||
                     'TABLESPACE ' || C_INDEX_TABLESPACE;
            EXECUTE IMMEDIATE l_stm;
    END;
    BEGIN
        SELECT 1
        INTO   l_dummy
        FROM   all_objects
        WHERE  owner = C_TABLE_OWNER
        AND    object_type = 'INDEX'
        AND    object_name = C_TABLE_NAME || '_N2';
    EXCEPTION
        WHEN no_data_found THEN
            l_stm := 'CREATE INDEX ' || C_TABLE_OWNER || '.'
                                     || C_TABLE_NAME  || '_N2 ' ||
                     '          ON ' || C_TABLE_OWNER || '.'
                                     || C_TABLE_NAME  ||
                     '(patch_name, status) ' ||
                     'TABLESPACE ' || C_INDEX_TABLESPACE;
            EXECUTE IMMEDIATE l_stm;
    END;
    -------------------------
    -- Creacion del sinonimo
    -------------------------
    IF (C_SYNONYM_OWNER IS NOT NULL) THEN
      BEGIN
        SELECT 1
        INTO   l_dummy
        FROM   all_objects
        WHERE  owner = C_SYNONYM_OWNER
        AND    object_type = 'SYNONYM'
        AND    object_name = C_TABLE_NAME;
      EXCEPTION
        WHEN no_data_found THEN
            l_stm := 'CREATE SYNONYM ' || C_SYNONYM_OWNER || '.'
                                       || C_TABLE_NAME    || ' ' ||
                     'FOR '            || C_TABLE_OWNER   || '.'
                                       || C_TABLE_NAME;
            EXECUTE IMMEDIATE l_stm;
      END;
    END IF;

EXCEPTION
    WHEN others THEN
        :v_return_status := C_EXIT_CODE_ERROR;
END;
/

EXIT :v_return_status;

END_OF_SQL\");

if ( ! \$l_result ) {
    \$TEXT_LINE=\"Tabla de log del proceso verificada exitosamente\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: No se pudo verificar la tabla de log del proceso\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    exit \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
}\n";




print TMPFH "
# --------------------------------------------------------------
#
# Routine    : LogProcess
# Purpose    : Genera un registro en la tabla de log del proceso
# Parameters : XXDBLOG_TABLE_DB_USR : Usuario dueno de la tabla
#              XXDBLOG_TABLE_DB_PWD : Password del usuario dueno
#              XXDBLOG_TABLE_NAME   : Nombre de la tabla de log
#              PATCH_NAME           : Nombre del parche
#              PATCH_RELEASE        : Version del parche
#              PATCH_SERVER         : Tipo de servidor (applicaciones o DB)
#              PATCH_LANGUAGE       : Lenguaje del parche
#              DRIVERFILE           : Nombre del archivo driver
#              LOGFILE              : Archivo de log
#
# --------------------------------------------------------------
sub LogProcess() {

# Obtengo los valores de las columnas a insertar en el log
\$COL_PATCH_NAME=\$PATCH_NAME;
\$COL_PATCH_RELEASE=\$PATCH_RELEASE;
\$COL_PATCH_SERVER=\$PATCH_SERVER;
\$COL_PATCH_LANG=\$PATCH_LANGUAGE;
\$COL_DRIVER_NAME=\`basename \$DRIVERFILE \`;
\$COL_LOG_FILE_NAME=\`basename \$LOGFILE \`;
\$COL_SERVER_NAME=\`uname -n \`;
\$COL_DIRECTORY_NAME=\`pwd \`;
\$COL_USER_NAME=\`id \`;

# Imprimo mensaje de informacion
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Generando log del proceso ...\";
    PrintLine();

# Genero el log
    \$l_result = system(\"sqlplus -s \$XXDBLOG_TABLE_DB_USR/\$XXDBLOG_TABLE_DB_PWD > /dev/null << END_OF_SQL

VARIABLE v_return_status NUMBER;

DECLARE
    ----------------------
    -- Constantes locales
    ----------------------
    C_EXIT_CODE_OK      CONSTANT INTEGER := 0;
    C_EXIT_CODE_ERROR   CONSTANT INTEGER := 1;
    ----------------------------------------------------------
    -- Variables para informacion de objetos de base de datos
    ----------------------------------------------------------
    C_TABLE_NAME        VARCHAR2(250);
    C_TABLE_OWNER       VARCHAR2(30);
    ---------------------
    -- Variables locales
    ---------------------
    l_stm   VARCHAR2(2000);
BEGIN
    -----------------------------------
    -- Inicializo el codigo de retorno
    -----------------------------------
    :v_return_status := C_EXIT_CODE_OK;

    --------------------------------------------------
    -- Obtengo los datos del usuario de base de datos
    -- y del nombre de la tabla de log
    --------------------------------------------------
    C_TABLE_NAME    := '\$XXDBLOG_TABLE_NAME';
    C_TABLE_OWNER   := '\$XXDBLOG_TABLE_DB_USR';
    IF (C_TABLE_OWNER = 'APPS') THEN
        C_TABLE_OWNER   := 'APPLSYS';
    END IF;

    ------------------------------------------
    -- Armo la sentencia para insertar el log
    ------------------------------------------
    l_stm := 'INSERT INTO ' || C_TABLE_OWNER || '.' || C_TABLE_NAME || ' ' ||
             '(patch_date, ' ||
             ' patch_name, ' ||
             ' patch_release, ' ||
             ' patch_server, ' ||
             ' language, ' ||
             ' status, ' ||
             ' driver_name, ' ||
             ' log_file_name, ' ||
             ' server_name, ' ||
             ' directory_name, ' ||
             ' user_name, ' ||
             ' error_count) ' ||
             'VALUES ' ||
             '(SYSDATE, ' ||
             '''\$COL_PATCH_NAME'' , ' ||
             '''\$COL_PATCH_RELEASE'' , ' ||
             '''\$COL_PATCH_SERVER'' , ' ||
             '''\$COL_PATCH_LANG'' , ' ||
             '''NOT_APPLIED'' , ' ||
             '''\$COL_DRIVER_NAME'' , ' ||
             '''\$COL_LOG_FILE_NAME'' , ' ||
             '''\$COL_SERVER_NAME'' , ' ||
             '''\$COL_DIRECTORY_NAME'' , ' ||
             '''\$COL_USER_NAME'' , ' ||
             '0) ';
    EXECUTE IMMEDIATE l_stm;

EXCEPTION
    WHEN others THEN
        :v_return_status := C_EXIT_CODE_ERROR;
END;
/

EXIT :v_return_status;

END_OF_SQL\");

if ( ! \$l_result ) {
    \$TEXT_LINE=\"Log generado exitosamente\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: No se pudo generar el log del proceso\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    exit \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
}\n";



print TMPFH "
# --------------------------------------------------------------
#
# Routine    : LogPatchError
# Purpose    : Incrementa la cantidad de errores en el log del parche
# Parameters : XXDBLOG_TABLE_DB_USR : Usuario dueno de la tabla
#              XXDBLOG_TABLE_DB_PWD : Password del usuario dueno
#              XXDBLOG_TABLE_NAME   : Nombre de la tabla de log
#              PATCH_NAME           : Nombre del parche
#              PATCH_RELEASE        : Version del parche
#              PATCH_SERVER         : Tipo de servidor (applicaciones o DB)
#              PATCH_LANGUAGE       : Lenguaje del parche
#              PATCH_ERRORS         : Cantidad de errores a incrementar
#
# --------------------------------------------------------------
sub LogPatchError() {

   \$TOTAL_PATCH_ERRORS=\$TOTAL_PATCH_ERRORS+\$PATCH_ERRORS;

   \$l_result = system(\"sqlplus -s \$XXDBLOG_TABLE_DB_USR/\$XXDBLOG_TABLE_DB_PWD > /dev/null << END_OF_SQL

VARIABLE v_return_status NUMBER;

DECLARE
    ----------------------
    -- Constantes locales
    ----------------------
    C_NULL_VALUE        CONSTANT VARCHAR2(240) := 'NULL';
    C_EXIT_CODE_OK      CONSTANT INTEGER := 0;
    C_EXIT_CODE_ERROR   CONSTANT INTEGER := 1;
    ----------------------------------------------------------
    -- Variables para informacion de objetos de base de datos
    ----------------------------------------------------------
    C_TABLE_NAME        VARCHAR2(250);
    C_TABLE_OWNER       VARCHAR2(30);
    ---------------------
    -- Variables locales
    ---------------------
    l_patch_name     VARCHAR2(240) := '\$PATCH_NAME';
    l_patch_release  VARCHAR2(240) := '\$PATCH_RELEASE';
    l_patch_server   VARCHAR2(240) := '\$PATCH_SERVER';
    l_patch_language VARCHAR2(240) := '\$PATCH_LANGUAGE';
    l_patch_errors   VARCHAR2(30)  := '\$PATCH_ERRORS';
    l_errors         NUMBER;
    l_stm            VARCHAR2(2000);
BEGIN
    -----------------------------------
    -- Inicializo el codigo de retorno
    -----------------------------------
    :v_return_status := C_EXIT_CODE_OK;

    --------------------------------------------------
    -- Obtengo los datos del usuario de base de datos
    -- y del nombre de la tabla de log
    --------------------------------------------------
    C_TABLE_NAME    := '\$XXDBLOG_TABLE_NAME';
    C_TABLE_OWNER   := '\$XXDBLOG_TABLE_DB_USR';
    IF (C_TABLE_OWNER = 'APPS') THEN
        C_TABLE_OWNER := 'APPLSYS';
    END IF;

    ------------------------------------------------
    -- Obtengo la cantidad de errores a incrementar
    ------------------------------------------------
    l_errors := to_number(nvl(l_patch_errors, 0));

    ------------------------------------------
    -- Armo la sentencia para insertar el log
    ------------------------------------------
    l_stm := 'UPDATE ' || C_TABLE_OWNER || '.' || C_TABLE_NAME          ||
            ' SET    error_count = error_count + :b_errors '            ||
            ' WHERE  patch_name = :b_patch_name '                       ||
            ' AND    nvl(patch_release, :b_null_value) = '              ||
            '        nvl(:b_patch_release, :b_null_value) '             ||
            ' AND    nvl(patch_server, :b_null_value) = '               ||
            '        nvl(:b_patch_server, :b_null_value) '              ||
            ' AND    nvl(language, :b_null_value) = '                   ||
            '        nvl(:b_patch_language, :b_null_value) '            ||
            ' AND    patch_date = '                                     ||
            '           (SELECT max(patch_date) '                       ||
            '            FROM ' || C_TABLE_OWNER || '.' || C_TABLE_NAME ||
            '            WHERE  patch_name = :b_patch_name '            ||
            '            AND    nvl(patch_release, :b_null_value) = '   ||
            '                   nvl(:b_patch_release, :b_null_value) '  ||
            '            AND    nvl(patch_server, :b_null_value) = '    ||
            '                   nvl(:b_patch_server, :b_null_value) '   ||
            '            AND    nvl(language, :b_null_value) = '        ||
            '                   nvl(:b_patch_language, :b_null_value))';

    EXECUTE IMMEDIATE l_stm
    USING l_errors,
          l_patch_name,
          C_NULL_VALUE,
          l_patch_release,
          C_NULL_VALUE,
          C_NULL_VALUE,
          l_patch_server,
          C_NULL_VALUE,
          C_NULL_VALUE,
          l_patch_language,
          C_NULL_VALUE,
          l_patch_name,
          C_NULL_VALUE,
          l_patch_release,
          C_NULL_VALUE,
          C_NULL_VALUE,
          l_patch_server,
          C_NULL_VALUE,
          C_NULL_VALUE,
          l_patch_language,
          C_NULL_VALUE;

EXCEPTION
    WHEN others THEN
        :v_return_status := C_EXIT_CODE_ERROR;
END;
/

EXIT :v_return_status;

END_OF_SQL\");

if ( \$l_result ) {
    \$TEXT_LINE=\"ERROR: No se pudieron actualizar los errores en el log\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    exit \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
}\n";



print TMPFH "
# --------------------------------------------------------------
#
# Routine    : UpdatePatchLog
# Purpose    : Actualiza el estado del parche en la tabla de log
# Parameters : XXDBLOG_TABLE_DB_USR : Usuario dueno de la tabla
#              XXDBLOG_TABLE_DB_PWD : Password del usuario dueno
#              XXDBLOG_TABLE_NAME   : Nombre de la tabla de log
#              PATCH_NAME           : Nombre del parche
#              PATCH_RELEASE        : Version del parche
#              PATCH_SERVER         : Tipo de servidor (applicaciones o DB)
#              PATCH_LANGUAGE       : Lenguaje del parche
#              PATCH_STATUS         : Nuevo estado
#
# --------------------------------------------------------------
sub UpdatePatchLog {

   \$l_result = system (\"sqlplus -s \$XXDBLOG_TABLE_DB_USR/\$XXDBLOG_TABLE_DB_PWD > /dev/null << END_OF_SQL

VARIABLE v_return_status NUMBER;

DECLARE
    ----------------------
    -- Constantes locales
    ----------------------
    C_NULL_VALUE        CONSTANT VARCHAR2(240) := 'NULL';
    C_EXIT_CODE_OK      CONSTANT INTEGER := 0;
    C_EXIT_CODE_ERROR   CONSTANT INTEGER := 1;
    ----------------------------------------------------------
    -- Variables para informacion de objetos de base de datos
    ----------------------------------------------------------
    C_TABLE_NAME        VARCHAR2(250);
    C_TABLE_OWNER       VARCHAR2(30);
    ---------------------
    -- Variables locales
    ---------------------
    l_patch_name     VARCHAR2(240) := '\$PATCH_NAME';
    l_patch_release  VARCHAR2(240) := '\$PATCH_RELEASE';
    l_patch_server   VARCHAR2(240) := '\$PATCH_SERVER';
    l_patch_language VARCHAR2(240) := '\$PATCH_LANGUAGE';
    l_patch_status   VARCHAR2(30)  := '\$PATCH_STATUS';
    l_stm            VARCHAR2(2000);
BEGIN

    -----------------------------------
    -- Inicializo el codigo de retorno
    -----------------------------------
    :v_return_status := C_EXIT_CODE_OK;

    --------------------------------------------------
    -- Obtengo los datos del usuario de base de datos
    -- y del nombre de la tabla de log
    --------------------------------------------------
    C_TABLE_NAME    := '\$XXDBLOG_TABLE_NAME';
    C_TABLE_OWNER   := '\$XXDBLOG_TABLE_DB_USR';
    IF (C_TABLE_OWNER = 'APPS') THEN
        C_TABLE_OWNER := 'APPLSYS';
    END IF;

    ----------------------------------
    -- Actualizo el estado del parche
    ----------------------------------
    l_stm := 'UPDATE ' || C_TABLE_OWNER || '.' || C_TABLE_NAME          ||
            ' SET    status = :b_patch_status '                         ||
            ' WHERE  patch_name = :b_patch_name '                       ||
            ' AND    nvl(patch_release, :b_null_value) = '              ||
            '        nvl(:b_patch_release, :b_null_value) '             ||
            ' AND    nvl(patch_server, :b_null_value) = '               ||
            '        nvl(:b_patch_server, :b_null_value) '              ||
            ' AND    nvl(language, :b_null_value) = '                   ||
            '        nvl(:b_patch_language, :b_null_value) '            ||
            ' AND    status != ''APPLIED'' '                            ||
            ' AND    patch_date = '                                     ||
            '           (SELECT max(patch_date) '                       ||
            '            FROM ' || C_TABLE_OWNER || '.' || C_TABLE_NAME ||
            '            WHERE  patch_name = :b_patch_name '            ||
            '            AND    nvl(patch_release, :b_null_value) = '   ||
            '                   nvl(:b_patch_release, :b_null_value) '  ||
            '            AND    nvl(patch_server, :b_null_value) = '    ||
            '                   nvl(:b_patch_server, :b_null_value) '   ||
            '            AND    nvl(language, :b_null_value) = '        ||
            '                   nvl(:b_patch_language, :b_null_value))';

    EXECUTE IMMEDIATE l_stm
    USING l_patch_status,
          l_patch_name,
          C_NULL_VALUE,
          l_patch_release,
          C_NULL_VALUE,
          C_NULL_VALUE,
          l_patch_server,
          C_NULL_VALUE,
          C_NULL_VALUE,
          l_patch_language,
          C_NULL_VALUE,
          l_patch_name,
          C_NULL_VALUE,
          l_patch_release,
          C_NULL_VALUE,
          C_NULL_VALUE,
          l_patch_server,
          C_NULL_VALUE,
          C_NULL_VALUE,
          l_patch_language,
          C_NULL_VALUE;

EXCEPTION
    WHEN others THEN
        :v_return_status := C_EXIT_CODE_ERROR;
END;
/

EXIT :v_return_status;

END_OF_SQL\");

if ( \$l_result ) {
   \$TEXT_LINE=\"ERROR: No se pudo actualizar el estado del parche en el log\";
    PrintLine();
   \$TEXT_LINE=\" \";
    PrintLine();
    exit \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
} \n";





print TMPFH "
# --------------------------------------------------------------
#
# Routine    : CheckDirectory
# Purpose    : Verifica si el directorio existe. Sino lo crea
# Parameters : TARGET_DIR : Directorio destino a verificar
#
# --------------------------------------------------------------
sub CheckDirectory {
    local \$LOCAL_TARGET_DIR=\$TARGET_DIR;
    chomp \$LOCAL_TARGET_DIR;
    if ( ! -d \$LOCAL_TARGET_DIR ) {
        \$TARGET_DIR=\`dirname \$LOCAL_TARGET_DIR\`;
        \$l_result = CheckDirectory();
        if ( \$l_result ) {
            \$TARGET_DIR=\$LOCAL_TARGET_DIR;
            return \$EXIT_CODE_ERROR;
        }
        # Se agrego al comando 0777 por compatibilidad
        # con perl v5.005_3
        mkdir \$LOCAL_TARGET_DIR,0777;
    }
    \$TARGET_DIR=\$LOCAL_TARGET_DIR;
    return \$EXIT_CODE_OK;
} \n";



print TMPFH "
# --------------------------------------------------------------
#
# Routine    : CopyFile
# Purpose    : Copiar fuentes a un directorio destino
# Parameters : SOURCE_FILE : Archivo fuente a copiar
#              SOURCE_DIR  : Directorio origen
#              TARGET_DIR  : Directorio destino
#              LOGFILE     : Archivo de log
#              BACKUP_FLAG : Indicador de backup
#
# --------------------------------------------------------------
sub CopyFile {

# FBarros 20-MAR-2010
# Inicializo una variable con el time stamp
\$TMSTP=`date '+%y%m%d%H%M%S'`;
# Fin FBarros 20-MAR-2010

# Verifico si existe el archivo origen
if ( ! -f \$SOURCE_DIR.\"/\".\$SOURCE_FILE ) {
 \$TEXT_LINE=\"ERROR: No se puede copiar \$SOURCE_FILE a \$TARGET_DIR. No existe el archivo\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio origen
if ( ! -d \$SOURCE_DIR ) {
 \$TEXT_LINE=\"ERROR: No se puede copiar \$SOURCE_FILE a \$TARGET_DIR. No existe el directorio origen\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio destino
\$l_result = CheckDirectory();
if ( \$l_result ) {
    \$TEXT_LINE=\"ERROR: No se puede copiar \$SOURCE_FILE a \$TARGET_DIR. El directorio destino no existe y no puede ser creado.\";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}

# Verifico si esta definido el archivo de log
if ( ! \$LOGFILE ) {
  \$TEXT_LINE=\"ERROR: No se puede copiar \$SOURCE_FILE a \$TARGET_DIR. No se definio archivo log\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si es necesario hacer backup antes de copiar
if ( -f \$TARGET_DIR.\"/\".\$SOURCE_FILE ) {
    if ( \$BACKUP_FLAG ) {
        if ( \$BACKUP_FLAG eq \"Y\" || \$BACKUP_FLAG eq \"y\" ) {
            \$TEXT_LINE=\"Haciendo un backup de \$TARGET_DIR/\$SOURCE_FILE\";
            PrintLine();
            system(\"cp \$TARGET_DIR/\$SOURCE_FILE \$TARGET_DIR/\$SOURCE_FILE.\$TMSTP\");
        }
    }
}

# Copio el fuente al directorio destino
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Copiando \$SOURCE_DIR/\$SOURCE_FILE a \$TARGET_DIR\";
    PrintLine();
    \$l_result = system (\"cp \$SOURCE_DIR/\$SOURCE_FILE \$TARGET_DIR\");
if ( !\$l_result ) {
    \$TEXT_LINE=\"Archivo \$SOURCE_DIR/\$SOURCE_FILE copiado exitosamente.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: Archivo \$SOURCE_DIR/\$SOURCE_FILE no pudo ser copiado.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;

} \n";




print TMPFH "
# --------------------------------------------------------------
#
# Routine    : MergeLibrary
# Purpose    : Fusiona dos librerias de Forms
# Parameters : SOURCE_FILE  : Nombre libreria a fusionar
#              SOURCE_DIR   : Directorio origen
#              TARGET_FILE  : Nombre libreria destino fusion
#              TARGET_DIR1  : Directorio destino 1
#              TARGET_DIR2  : Directorio destino 2
#              MERGEOPTIONS : Opciones adicionales para la fusion
#              LOGFILE      : Archivo de log
#              BACKUP_FLAG  : Indicador de backup
#
# --------------------------------------------------------------
sub MergeLibrary {

# Inicializo una variable con el time stamp
\$TMSTP=`date '+%y%m%d%H%M%S'`;

# Verifico si existe el archivo origen
if ( ! -f \$SOURCE_DIR.\"/\".\$SOURCE_FILE ) {
  \$TEXT_LINE=\"ERROR: No se puede fusionar \$SOURCE_FILE. No existe el archivo\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio origen
if ( ! -d \$SOURCE_DIR ) {
  \$TEXT_LINE=\"ERROR: No se puede fusionar \$SOURCE_FILE. No existe el directorio origen\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio destino 1
\$TARGET_DIR=\$TARGET_DIR1;
\$l_result = CheckDirectory();
if ( \$l_result ) {
    \$TEXT_LINE=\"ERROR: No se puede fusionar \$SOURCE_FILE. El directorio destino 1 no existe y no puede ser creado.\";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio destino 2
if ( \$TARGET_DIR1 ne \$TARGET_DIR2 ) {
    \$TARGET_DIR=\$TARGET_DIR2;
    \$l_result = CheckDirectory ();
    if ( \$l_result ) {
        \$TEXT_LINE=\"ERROR: No se puede fusionar \$SOURCE_FILE. El directorio destino 2 no existe y no puede ser creado.\";
        PrintLine();
        return \$EXIT_CODE_ERROR;
    }
}

# Verifico si esta definido el archivo de log
if ( ! \$LOGFILE ) {
  \$TEXT_LINE=\"ERROR: No se puede fusionar \$SOURCE_FILE. No se definio archivo log\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si es necesario hacer backup en el directorio destino 1
\$TARGET_DIR=\$TARGET_DIR1;
if ( -f \$TARGET_DIR.\"/\".\$TARGET_FILE ) {
    if ( \$BACKUP_FLAG ) {
        if ( \$BACKUP_FLAG eq \"Y\" || \$BACKUP_FLAG eq \"y\" ) {
            \$TEXT_LINE=\"Haciendo un backup de \$TARGET_DIR/\$TARGET_FILE\";
            PrintLine();
            system(\"cp \$TARGET_DIR/\$TARGET_FILE \$TARGET_DIR/\$TARGET_FILE.\$TMSTP\");
        }
    }
}

# Verifico si es necesario hacer backup en el directorio destino 2
if ( \$TARGET_DIR1 ne \$TARGET_DIR2 ) {
    \$TARGET_DIR=\$TARGET_DIR2;
    if ( -f \$TARGET_DIR.\"/\".\$TARGET_FILE ) {
        if ( \$BACKUP_FLAG ) {
            if ( \$BACKUP_FLAG eq \"Y\" || \$BACKUP_FLAG eq \"y\" ) {
                \$TEXT_LINE=\"Haciendo un backup de \$TARGET_DIR/\$TARGET_FILE\";
                PrintLine();
                system(\"cp \$TARGET_DIR/\$TARGET_FILE \$TARGET_DIR/\$TARGET_FILE.\$TMSTP\");
            }
        }
    }
}

# Para llevar a cabo la fusion, es necesario que existan dos librerias.
# Si la libreria del directorio destino 1 no existe, entonces copio la
# misma libreria del directorio origen al directorio destino 1 para hacer
# una fusion consigo misma
if ( ! -f \$TARGET_DIR1.\"/\".\$TARGET_FILE ) {
    \$TEXT_LINE=\"No existe version previa de la libreria \$TARGET_FILE\";
    PrintLine();
    system(\"cp \$SOURCE_DIR/\$SOURCE_FILE \$TARGET_DIR1/\$TARGET_FILE\");
}

# Fusiono la libreria origen y la libreria destino
   \$TEXT_LINE=\" \";
    PrintLine();
#   \$TEXT_LINE=\"### Fusionando libreria \$SOURCE_FILE con \$TARGET_FILE\";
   \$TEXT_LINE=\"### Fusionando libreria \$TARGET_FILE con \$SOURCE_FILE\";
    PrintLine();

#    \$l_result = system(\"\\\$XBOL_TOP\/bin\/xxmergelib \$MERGEOPTIONS -u \$COMMAND_DB_USR/\$COMMAND_DB_PWD -l \$LOGFILE -t \$TMP_DIR \$SOURCE_DIR/\$SOURCE_FILE \$TARGET_DIR1/\$TARGET_FILE \$TARGET_DIR1/\$TARGET_FILE\");
    \$l_result = system(\"\\\$XBOL_TOP\/bin\/xxmergelib \$MERGEOPTIONS -u \$COMMAND_DB_USR/\$COMMAND_DB_PWD -l \$LOGFILE -t \$TMP_DIR \$TARGET_DIR1/\$TARGET_FILE \$SOURCE_DIR/\$SOURCE_FILE \$TARGET_DIR1/\$TARGET_FILE\");
if ( ! \$l_result ) {
    \$TEXT_LINE=\"Libreria \$SOURCE_FILE fusionada exitosamente.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: Libreria \$SOURCE_FILE no pudo ser fusionada.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}



# Finalmente, copio la libreria fusionada en el directorio destino 2
if ( \$TARGET_DIR1 ne \$TARGET_DIR2 ) {
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Copiando libreria fusionada \$TARGET_FILE a \$TARGET_DIR2\";
    PrintLine();
    \$l_result = system(\"cp \$TARGET_DIR1/\$TARGET_FILE \$TARGET_DIR2\");
    if ( ! \$l_result ) {
      \$TEXT_LINE=\"Libreria fusionada \$TARGET_FILE copiada exitosamente.\";
      PrintLine();
      \$TEXT_LINE=\" \";
      PrintLine();
    } else {
      \$TEXT_LINE=\"ERROR: Libreria fusionada \$TARGET_FILE no pudo ser copiada.\";
      PrintLine();
      \$TEXT_LINE=\" \";
      PrintLine();
      return \$EXIT_CODE_ERROR;
    }
}
return \$EXIT_CODE_OK;

} \n";




print TMPFH "
# --------------------------------------------------------------
#
# Routine    : PurgeLibrary
# Purpose    : Depura una libreria (utilizando el comando de fusion)
# Parameters : SOURCE_FILE  : Nombre libreria a depurar
#              SOURCE_DIR   : Directorio origen
#              TARGET_DIR1  : Directorio destino 1
#              TARGET_DIR2  : Directorio destino 2
#              MERGEOPTIONS : Opciones adicionales para la depuracion
#              LOGFILE      : Archivo de log
#              BACKUP_FLAG  : Indicador de backup
#
# --------------------------------------------------------------
sub PurgeLibrary {

# Inicializo una variable con el time stamp
\$TMSTP=`date '+%y%m%d%H%M%S'`;

# Verifico si existe el archivo origen
if ( ! -f \$SOURCE_DIR.\"/\".\$SOURCE_FILE ) {
  \$TEXT_LINE=\"ERROR: No se puede depurar \$SOURCE_FILE. No existe el archivo\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio origen
if ( ! -d \$SOURCE_DIR ) {
  \$TEXT_LINE=\"ERROR: No se puede depurar \$SOURCE_FILE. No existe el directorio origen\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio destino 1
\$TARGET_DIR=\$TARGET_DIR1;
\$l_result = CheckDirectory();
if ( \$l_result ) {
    \$TEXT_LINE=\"ERROR: No se puede depurar \$SOURCE_FILE. El directorio destino 1 no existe y no puede ser creado.\";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio destino 2
if ( \$TARGET_DIR1 ne \$TARGET_DIR2 ) {
    \$TARGET_DIR=\$TARGET_DIR2;
    \#l_result = CheckDirectory();
    if ( \$l_result ) {
        \$TEXT_LINE=\"ERROR: No se puede depurar \$SOURCE_FILE. El directorio destino 2 no existe y no puede ser creado.\";
        PrintLine();
        return \$EXIT_CODE_ERROR;
    }
}

# Verifico si esta definido el archivo de log
if ( ! \$LOGFILE ) {
  \$TEXT_LINE=\"ERROR: No se puede depurar \$SOURCE_FILE. No se definio archivo log\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si es necesario hacer backup en el directorio destino 1
\$TARGET_DIR=\$TARGET_DIR1;
if ( -f \$TARGET_DIR.\"/\".\$SOURCE_FILE ) {
    if ( \$BACKUP_FLAG ) {
        if ( \$BACKUP_FLAG eq \"Y\" || \$BACKUP_FLAG eq \"y\" ) {
            \$TEXT_LINE=\"Haciendo un backup de \$TARGET_DIR/\$SOURCE_FILE\";
            PrintLine();
            system(\"cp \$TARGET_DIR/\$SOURCE_FILE \$TARGET_DIR/\$SOURCE_FILE.\$TMSTP\");
        }
    }
}

# Verifico si es necesario hacer backup en el directorio destino 2
if ( \$TARGET_DIR1 ne \$TARGET_DIR2 ) {
    \$TARGET_DIR=\$TARGET_DIR2;
    if ( -f \$TARGET_DIR.\"/\".\$SOURCE_FILE ) {
        if ( \$BACKUP_FLAG ) {
            if ( \$BACKUP_FLAG eq \"Y\" || \$BACKUP_FLAG eq \"y\" ) {
                \$TEXT_LINE=\"Haciendo un backup de \$TARGET_DIR/\$SOURCE_FILE\";
                PrintLine();
                system(\"cp \$TARGET_DIR/\$SOURCE_FILE \$TARGET_DIR/\$SOURCE_FILE.\$TMSTP\");
            }
        }
    }
}


# Para llevar a cabo la depuracion, es necesario que existan dos librerias.
# Si la libreria del directorio destino 1 no existe, entonces copio la
# misma libreria del directorio origen al directorio destino 1 para hacer
# una fusion consigo misma
if ( ! -f \$TARGET_DIR1.\"/\".\$SOURCE_FILE ) {
    \$TEXT_LINE=\"No existe version previa de la libreria \$SOURCE_FILE\";
    PrintLine();
    system(\"cp \$SOURCE_DIR/\$SOURCE_FILE \$TARGET_DIR1/\$SOURCE_FILE\");
}

# Fusiono la libreria origen y la libreria destino (con la opcion \"purge\")
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Depurando (fusionando) libreria \$SOURCE_FILE\";
    PrintLine();
    \$l_result = system(\"\\\$XBOL_TOP\/bin\/xxmergelib \$MERGEOPTIONS -u \$COMMAND_DB_USR/\$COMMAND_DB_PWD -l \$LOGFILE -t \$TMP_DIR \$SOURCE_DIR/\$SOURCE_FILE \$TARGET_DIR1/\$SOURCE_FILE \$TARGET_DIR1/\$SOURCE_FILE \");
if ( ! \$l_result ) {
    \$TEXT_LINE=\"Libreria \$SOURCE_FILE depurada exitosamente.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
   \$TEXT_LINE=\"ERROR: Libreria \$SOURCE_FILE no pudo ser depurada.\";
    PrintLine();
   \$TEXT_LINE=\" \";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}


# Finalmente, copio la libreria depurada en el directorio destino 2
if ( \$TARGET_DIR1 ne \$TARGET_DIR2 ) {
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Copiando libreria depurada \$SOURCE_FILE a \$TARGET_DIR2\";
    PrintLine();
    \$l_result = system(\"cp \$TARGET_DIR1/\$SOURCE_FILE \$TARGET_DIR2\");

    if ( ! \$l_result ) {
      \$TEXT_LINE=\"Libreria depurada \$SOURCE_FILE copiada exitosamente.\";
      PrintLine();
      \$TEXT_LINE=\" \";
      PrintLine();
    } else {
      \$TEXT_LINE=\"ERROR: Libreria depurada \$SOURCE_FILE no pudo ser copiada.\";
      PrintLine();
      \$TEXT_LINE=\" \";
      PrintLine();
      return \$EXIT_CODE_ERROR;
    }
}
return \$EXIT_CODE_OK;

} \n";





print TMPFH "
# --------------------------------------------------------------
#
# Routine    : ExecuteSQL
# Purpose    : Ejecuta un script SQL
# Parameters : SOURCE_FILE : Archivo fuente a ejecutar
#              SOURCE_DIR  : Directorio origen
#              LOGFILE     : Archivo de log
#
# --------------------------------------------------------------
sub ExecuteSQL {

# Verifico si existe el archivo origen
if ( ! -f \$SOURCE_DIR.\"/\".\$SOURCE_FILE ) {
  \$TEXT_LINE=\"ERROR: No se puede ejecutar \$SOURCE_FILE. No existe el archivo\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio origen
if ( ! -d \$SOURCE_DIR ) {
  \$TEXT_LINE=\"ERROR: No se puede ejecutar \$SOURCE_FILE. No existe el directorio origen\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si esta definido el archivo de log
if ( ! \$LOGFILE ) {
  \$TEXT_LINE=\"ERROR: No se puede ejecutar \$SOURCE_FILE. No se definio archivo log\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Ejecuto el script SQL
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Ejecutando \$SOURCE_DIR/\$SOURCE_FILE\";
    PrintLine();
##    \$TEXT_LINE=\"### Con el usuario \$COMMAND_DB_USR/\$COMMAND_DB_PWD\";
    \$TEXT_LINE=\"### Con el usuario \$COMMAND_DB_USR/***********\";
    PrintLine();
    \$l_result = system (\"sqlplus \$COMMAND_DB_USR/\$COMMAND_DB_PWD @ \$SOURCE_DIR/\$SOURCE_FILE | tee -a \$LOGFILE\");

if ( ! \$l_result ) {
    \$TEXT_LINE=\"Script \$SOURCE_DIR/\$SOURCE_FILE ejecutado exitosamente.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: Script \$SOURCE_DIR/\$SOURCE_FILE no pudo ser ejecutado.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
} \n";



print TMPFH "
# --------------------------------------------------------------
#
# Routine    : GenerateForm
# Purpose    : Genera el ejecutable de un form
# Parameters : SOURCE_FILE : Archivo fuente a generar
#              SOURCE_DIR  : Directorio origen
#              TARGET_DIR  : Directorio destino
#              LOGFILE     : Archivo de log
#
# --------------------------------------------------------------
sub GenerateForm {

# Verifico si existe el archivo origen
if ( ! -f \$SOURCE_DIR.\"/\".\$SOURCE_FILE ) {
 \$TEXT_LINE=\"ERROR: No se puede generar form \$SOURCE_FILE en \$TARGET_DIR. No existe el archivo\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio origen
if ( ! -d \$SOURCE_DIR ) {
 \$TEXT_LINE=\"ERROR: No se puede generar form \$SOURCE_FILE en \$TARGET_DIR. No existe el directorio origen\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio destino
\$l_result = CheckDirectory();
if ( \$l_result ) {
    \$TEXT_LINE=\"ERROR: No se puede generar form \$SOURCE_FILE en \$TARGET_DIR. El directorio destino no existe y no puede ser creado.\";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}

# Verifico si esta definido el archivo de log
if ( ! \$LOGFILE ) {
  \$TEXT_LINE=\"ERROR: No se puede generar form \$SOURCE_FILE en \$TARGET_DIR. No se definio archivo log\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Genero el form
\$CURRENT_DIR=\`pwd\`;
chomp \$CURRENT_DIR;

\$BASEFORMNAME=\`basename \$SOURCE_FILE .fmb\`;
chomp \$BASEFORMNAME;

    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Generando form \$SOURCE_DIR/\$SOURCE_FILE en \$TARGET_DIR\";
    PrintLine();
    chdir \$SOURCE_DIR;
    \$l_result = system(\"frmcmp_batch module=\$SOURCE_DIR/\$SOURCE_FILE userid=\$COMMAND_DB_USR/\$COMMAND_DB_PWD module_type=form output_file=\$TARGET_DIR/\$BASEFORMNAME\.fmx compile_all=special batch=yes\");

chdir \$CURRENT_DIR;

if ( ! \$l_result ) {
    \$TEXT_LINE=\"Form \$SOURCE_DIR/\$SOURCE_FILE generado exitosamente.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: Form \$SOURCE_DIR/\$SOURCE_FILE generado con errores.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
} \n";



print TMPFH "
# --------------------------------------------------------------
#
# Routine    : GenerateLibrary
# Purpose    : Genera el ejecutable de una libreria
# Parameters : SOURCE_FILE : Archivo fuente a generar
#              SOURCE_DIR  : Directorio origen
#              TARGET_DIR  : Directorio destino
#              LOGFILE     : Archivo de log
#
# --------------------------------------------------------------
sub GenerateLibrary {

# Verifico si existe el archivo origen
if ( ! -f \$SOURCE_DIR.\"/\".\$SOURCE_FILE ) {
  \$TEXT_LINE=\"ERROR: No se puede generar libreria \$SOURCE_FILE en \$TARGET_DIR. No existe el archivo\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio origen
if ( ! -d \$SOURCE_DIR ) {
 \$TEXT_LINE=\"ERROR: No se puede generar libreria \$SOURCE_FILE en \$TARGET_DIR. No existe el directorio origen\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio destino
\$l_result = CheckDirectory();
if ( \$l_result ) {
    \$TEXT_LINE=\"ERROR: No se puede generar libreria \$SOURCE_FILE en \$TARGET_DIR. El directorio destino no existe y no puede ser creado.\";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}

# Verifico si esta definido el archivo de log
if ( ! \$LOGFILE ) {
  \$TEXT_LINE=\"ERROR: No se puede generar libreria \$SOURCE_FILE en \$TARGET_DIR. No se definio archivo log\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}


# Genero la libreria
\$CURRENT_DIR=\`pwd\`;
chomp \$CURRENT_DIR;
\$BASEFORMNAME=\`basename \$SOURCE_FILE .pll\`;
chomp \$BASEFORMNAME;
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Generando libreria \$SOURCE_DIR/\$SOURCE_FILE en \$TARGET_DIR\";
    PrintLine();
    chdir \$SOURCE_DIR;
    \$l_result = system (\"frmcmp_batch module=\$SOURCE_DIR/\$SOURCE_FILE userid=\$COMMAND_DB_USR/\$COMMAND_DB_PWD module_type=library output_file=\$TARGET_DIR/\$BASEFORMNAME\.plx compile_all=special batch=yes\");

chdir \$CURRENT_DIR;

if ( ! \$l_result ) {
    \$TEXT_LINE=\"Libreria \$SOURCE_DIR/\$SOURCE_FILE generada exitosamente.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: Libreria \$SOURCE_DIR/\$SOURCE_FILE generada con errores.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
} \n";


print TMPFH "
# --------------------------------------------------------------
#
# Routine    : ExecuteJava
# Purpose    : Ejecuta un archivo
# Parameters : 
#              SOURCE_FILE : Clase origen
#              PARAMETERS  : Parametros para la ejecucion
#              LOGFILE     : Archivo de log
#
# --------------------------------------------------------------
sub ExecuteJava {

   # FGBM Se elimina la utilizacion de la Clase XXValidatorCommand
   # Valido Exista Clase Java
   # \$l_result = system(\"java oracle.apps.xbol.util.XXValidatorCommand valclass \$SOURCE_FILE 2>> \$LOGFILE \");

   # if (  \$l_result ) {
   #     \$TEXT_LINE=\"ERROR: Comando java clase \$SOURCE_FILE ejecutado con errores.\";
   #     PrintLine();
   #     \$TEXT_LINE=\" \";
   #     PrintLine();
   #     return \$EXIT_CODE_ERROR;
   # 

# Verifico si esta definido el archivo de log
if ( ! \$LOGFILE ) {
  \$TEXT_LINE=\"ERROR: No se puede ejecutar archivo \$SOURCE_FILE. No se definio archivo log\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Reemplazo, en los parametros, las passwords de los usuarios de base de datos
\$XX_TEXT_TO_BE_REPLACED=\$PARAMETERS;
\$XX_TEXT_REPLACED = Replace_User_Passwords();
\$PARAMETERS=\$XX_TEXT_REPLACED;

# Reemplazo, en los parametros, la conexion a la  base de datos
\$XX_TEXT_TO_BE_REPLACED=\$PARAMETERS;
\$XX_TEXT_REPLACED = Replace_Connection();
\$PARAMETERS=\$XX_TEXT_REPLACED;


# Ejecuto el archivo
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Ejecutando comando java clase \$SOURCE_FILE\";
    PrintLine();
    \$l_result = system(\"java \$SOURCE_FILE \$PARAMETERS\");

if ( ! \$l_result ) {
    \$TEXT_LINE=\"Comando java clase \$SOURCE_FILE ejecutado exitosamente.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: Comando java clase \$SOURCE_FILE ejecutado con errores.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
} \n";



print TMPFH "
# --------------------------------------------------------------
#
# Routine    : ExecuteFile
# Purpose    : Ejecuta un archivo
# Parameters : SOURCE_FILE : Archivo fuente a ejecutar
#              SOURCE_DIR  : Directorio origen
#              PARAMETERS  : Parametros para la ejecucion
#              LOGFILE     : Archivo de log
#
# --------------------------------------------------------------
sub ExecuteFile {

# Verifico si existe el archivo origen
if ( ! -f \$SOURCE_DIR.\"/\".\$SOURCE_FILE ) {
  \$TEXT_LINE=\"ERROR: No se puede ejecutar archivo \$SOURCE_FILE. No existe el archivo\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si existe el directorio origen
if ( ! -d \$SOURCE_DIR ) {
  \$TEXT_LINE=\"ERROR: No se puede ejecutar archivo \$SOURCE_FILE. No existe el directorio origen\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}

# Verifico si esta definido el archivo de log
if ( ! \$LOGFILE ) {
  \$TEXT_LINE=\"ERROR: No se puede ejecutar archivo \$SOURCE_FILE. No se definio archivo log\";
  PrintLine();
  return \$EXIT_CODE_ERROR;
}


# Reemplazo, en los parametros, las passwords de los usuarios de base de datos
\$XX_TEXT_TO_BE_REPLACED=\$PARAMETERS;
\$XX_TEXT_REPLACED = Replace_User_Passwords();
\$PARAMETERS=\$XX_TEXT_REPLACED;


# Ejecuto el archivo
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"### Ejecutando archivo \$SOURCE_DIR/\$SOURCE_FILE\";
    PrintLine();
    \$l_result = system(\"\$SOURCE_DIR/\$SOURCE_FILE \$PARAMETERS\");

if ( ! \$l_result ) {
    \$TEXT_LINE=\"Archivo \$SOURCE_DIR/\$SOURCE_FILE ejecutado exitosamente.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$TEXT_LINE=\"ERROR: Archivo \$SOURCE_DIR/\$SOURCE_FILE ejecutado con errores.\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    return \$EXIT_CODE_ERROR;
}
return \$EXIT_CODE_OK;
} \n";




print TMPFH "
# --------------------------------------------------------------
#
# Routine    : CheckPrereq
# Purpose    : Verifica prerequisitos del parche
# Parameters : XXDBLOG_TABLE_DB_USR : Usuario dueno de la tabla
#              XXDBLOG_TABLE_DB_PWD : Password del usuario dueno
#              XXDBLOG_TABLE_NAME   : Nombre de la tabla de log
#              PREREQ_PATCH         : Nombre del parche prerequisito
#              PREREQ_RELEASE       : Version del parche
#              PREREQ_SERVER        : Tipo de servidor
#              PREREQ_LANGUAGE      : Lenguaje del parche
#
# --------------------------------------------------------------
sub CheckPrereq {

   # Imprimo mensaje de informacion
   \$TEXT_LINE=\" \";
   PrintLine();
   \$TEXT_LINE=\"### Verificando Prerequisito \$PREREQ_PATCH del Parche ...\";
   PrintLine();

   \$l_result = system (\"sqlplus -s \$XXDBLOG_TABLE_DB_USR/\$XXDBLOG_TABLE_DB_PWD > /dev/null << END_OF_SQL

VARIABLE v_return_status NUMBER;

DECLARE
    ----------------------
    -- Constantes locales
    ----------------------
    C_MAX_REL_SIZE      CONSTANT NUMBER  := 240;
    C_EXIT_CODE_OK      CONSTANT INTEGER := 0;
    C_EXIT_CODE_ERROR   CONSTANT INTEGER := 1;
    ----------------------------------------------------------
    -- Variables para informacion de objetos de base de datos
    ----------------------------------------------------------
    C_TABLE_NAME        VARCHAR2(250);
    C_TABLE_OWNER       VARCHAR2(30);
    --------------------------
    -- Tipos de datos locales
    --------------------------
    TYPE Applied_Patches_Cur IS REF CURSOR;
    TYPE Applied_Patch_Rec IS RECORD (
      patch_name       VARCHAR2(240),
      patch_release    VARCHAR2(240),
      patch_server     VARCHAR2(240),
      patch_language   VARCHAR2(240));
    ---------------------
    -- Variables locales
    ---------------------
    l_prereq_found   BOOLEAN := FALSE;
    l_patch_name     VARCHAR2(240) := '\$PREREQ_PATCH';
    l_patch_release  VARCHAR2(240) := '\$PREREQ_RELEASE';
    l_patch_server   VARCHAR2(240) := '\$PREREQ_SERVER';
    l_patch_language VARCHAR2(240) := '\$PREREQ_LANGUAGE';
    l_rel1           VARCHAR2(1000);
    l_rel2           VARCHAR2(1000);
    l_stm            VARCHAR2(2000);
    c_patches        Applied_Patches_Cur;
    r_patch          Applied_Patch_Rec;
BEGIN
    -----------------------------------
    -- Inicializo el codigo de retorno
    -----------------------------------
    :v_return_status := C_EXIT_CODE_OK;

    --------------------------------------------------
    -- Obtengo los datos del usuario de base de datos
    -- y del nombre de la tabla de log
    --------------------------------------------------
    C_TABLE_NAME    := '\$XXDBLOG_TABLE_NAME';
    C_TABLE_OWNER   := '\$XXDBLOG_TABLE_DB_USR';
    IF (C_TABLE_OWNER = 'APPS') THEN
        C_TABLE_OWNER := 'APPLSYS';
    END IF;

    ---------------------------------------------
    -- Armo la sentencia SQL del cursor dinamico
    ---------------------------------------------
    l_stm := 'SELECT patch_name, '                                  ||
             '       patch_release, '                               ||
             '       patch_server, '                                ||
             '       language patch_language '                      ||
             'FROM ' || C_TABLE_OWNER || '.' || C_TABLE_NAME || ' ' ||
             'WHERE  patch_name = :b_patch_name '                   ||
             'AND    status = ''APPLIED''';


    ------------------------------------------
    -- Recorro el cursor de parches aplicados
    ------------------------------------------
    OPEN c_patches FOR l_stm USING l_patch_name;
    LOOP
        FETCH c_patches INTO r_patch;
        EXIT WHEN c_patches%NOTFOUND;

        -----------------------------------------------------------
        -- En principio, inicializo la variable auxiliar indicando
        -- que el prerequisito existe
        -----------------------------------------------------------
        l_prereq_found := TRUE;

        ----------------------------------
        -- Verifico si el idioma coincide
        ----------------------------------
        IF (l_patch_language IS NOT NULL) THEN
            IF (r_patch.patch_language IS NULL) THEN
                l_prereq_found := FALSE;
            ELSIF (r_patch.patch_language != l_patch_language) THEN
                l_prereq_found := FALSE;
            END IF;
        END IF;

        ------------------------------------
        -- Verifico si el servidor coincide
        ------------------------------------
        IF (l_patch_server IS NOT NULL) THEN
            IF (r_patch.patch_server IS NULL) THEN
                l_prereq_found := FALSE;
            ELSIF (r_patch.patch_server != l_patch_server) THEN
                l_prereq_found := FALSE;
            END IF;
        END IF;

        ---------------------------------------------------
        -- Verifico si la version coincide (o es superior)
        ---------------------------------------------------
        IF (l_patch_release IS NOT NULL) THEN
            IF (r_patch.patch_release IS NULL) THEN
                l_prereq_found := FALSE;
            ELSIF (r_patch.patch_release != l_patch_release) THEN
                SELECT lpad(r_patch.patch_release,
                            decode(instr(r_patch.patch_release, '.', 1), 0,
                                   C_MAX_REL_SIZE,
                                   C_MAX_REL_SIZE +
                                     length(r_patch.patch_release) -
                                     instr(r_patch.patch_release, '.', 1) +
                                     1),
                            ' ') rel1,
                       lpad(l_patch_release,
                            decode(instr(l_patch_release, '.', 1), 0,
                                   C_MAX_REL_SIZE,
                                   C_MAX_REL_SIZE +
                                     length(l_patch_release) -
                                     instr(l_patch_release, '.', 1) +
                                     1),
                            ' ') rel2
                INTO l_rel1, l_rel2
                FROM dual;
                IF (l_rel1 < l_rel2) THEN
                    l_prereq_found := FALSE;
                END IF;
            END IF;
        END IF;

        IF (l_prereq_found) THEN
            EXIT;
        END IF;

    END LOOP;
    CLOSE c_patches;

 
    -------------------------------------------------
    -- Devuelvo el codigo de retorno que corresponda
    -------------------------------------------------
    IF (l_prereq_found) THEN
        :v_return_status := C_EXIT_CODE_OK;
    ELSE
        :v_return_status := C_EXIT_CODE_ERROR;
    END IF;

EXCEPTION
    WHEN others THEN
        :v_return_status := C_EXIT_CODE_ERROR;
END;
/

EXIT :v_return_status;

END_OF_SQL\");


if ( ! \$l_result ) {
   \$TEXT_LINE=\"Prerequisito verificado exitosamente\";
    PrintLine();
   \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$CONFIRM_PREREQ=\"N\";
    \$TEXT_LINE=\"ERROR: No se pudo verificar el prerequisito del parche\";
    PrintLine();
    \$TEXT_LINE=\" # Patch    : \$PREREQ_PATCH\";
    PrintLine();
    \$TEXT_LINE=\" # Release  : \$PREREQ_RELEASE\";
    PrintLine();
    \$TEXT_LINE=\" # Server   : \$PREREQ_SERVER\";
    PrintLine();
    \$TEXT_LINE=\" # Language : \$PREREQ_LANGUAGE\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"Desea continuar de todas formas con la aplicacion del parche (y/n)?\";
    PrintLine();
    \$CONFIRM_PREREQ = <STDIN>;
    chomp \$CONFIRM_PREREQ ;

    if ( \"\$CONFIRM_PREREQ\" ne \"Y\" && \"\$CONFIRM_PREREQ\" ne \"y\" ) {
        \$TEXT_LINE=\"Aplicacion del parche abortada.\";
        PrintLine();
        \$PATCH_STATUS=\"PREREQ_FAILED\";
        UpdatePatchLog();
        exit \$EXIT_CODE_ERROR;
    } else {
        \$TEXT_LINE=\" \";
        PrintLine();
    }
}

return \$EXIT_CODE_OK;

} \n";

# FBarros 20-MAR-2010
print TMPFH "
# --------------------------------------------------------------
#
# Routine    : CheckPatchVersion
# Purpose    : Verifica prerequisitos del parche
# Parameters : XXDBLOG_TABLE_DB_USR : Usuario dueno de la tabla
#              XXDBLOG_TABLE_DB_PWD : Password del usuario dueno
#              XXDBLOG_TABLE_NAME   : Nombre de la tabla de log
#              PATCH_PATCH         : Nombre del parche prerequisito
#              PATCH_RELEASE       : Version del parche
#              PATCH_SERVER        : Tipo de servidor
#              PATCH_LANGUAGE      : Lenguaje del parche
#
# --------------------------------------------------------------
sub CheckPatchVersion {

   # Imprimo mensaje de informacion
   \$TEXT_LINE=\" \";
   PrintLine();
   \$TEXT_LINE=\"### Verificando Prerequisito \$PATCH_PATCH del Parche ...\";
   PrintLine();

   \$l_result = system (\"sqlplus -s \$XXDBLOG_TABLE_DB_USR/\$XXDBLOG_TABLE_DB_PWD > /dev/null << END_OF_SQL

VARIABLE v_return_status NUMBER;

DECLARE
    ----------------------
    -- Constantes locales
    ----------------------
    C_MAX_REL_SIZE      CONSTANT NUMBER  := 240;
    C_EXIT_CODE_OK      CONSTANT INTEGER := 0;
    C_EXIT_CODE_ERROR   CONSTANT INTEGER := 1;
    ----------------------------------------------------------
    -- Variables para informacion de objetos de base de datos
    ----------------------------------------------------------
    C_TABLE_NAME        VARCHAR2(250);
    C_TABLE_OWNER       VARCHAR2(30);
    --------------------------
    -- Tipos de datos locales
    --------------------------
    TYPE Applied_Patches_Cur IS REF CURSOR;
    TYPE Applied_Patch_Rec IS RECORD (
      patch_name       VARCHAR2(240),
      patch_release    VARCHAR2(240),
      patch_server     VARCHAR2(240),
      patch_language   VARCHAR2(240));
    ---------------------
    -- Variables locales
    ---------------------
    l_prereq_found   BOOLEAN := FALSE;
    l_patch_name     VARCHAR2(240) := '\$PATCH_PATCH';
    l_patch_release  VARCHAR2(240) := '\$PATCH_RELEASE';
    l_patch_server   VARCHAR2(240) := '\$PATCH_SERVER';
    l_patch_language VARCHAR2(240) := '\$PATCH_LANGUAGE';
    l_rel1           VARCHAR2(1000);
    l_rel2           VARCHAR2(1000);
    l_stm            VARCHAR2(2000);
    c_patches        Applied_Patches_Cur;
    r_patch          Applied_Patch_Rec;
BEGIN
    -----------------------------------
    -- Inicializo el codigo de retorno
    -----------------------------------
    :v_return_status := C_EXIT_CODE_OK;

    --------------------------------------------------
    -- Obtengo los datos del usuario de base de datos
    -- y del nombre de la tabla de log
    --------------------------------------------------
    C_TABLE_NAME    := '\$XXDBLOG_TABLE_NAME';
    C_TABLE_OWNER   := '\$XXDBLOG_TABLE_DB_USR';
    IF (C_TABLE_OWNER = 'APPS') THEN
        C_TABLE_OWNER := 'APPLSYS';
    END IF;

    ---------------------------------------------
    -- Armo la sentencia SQL del cursor dinamico
    ---------------------------------------------
    l_stm := 'SELECT patch_name, '                                  ||
             '       patch_release, '                               ||
             '       patch_server, '                                ||
             '       language patch_language '                      ||
             'FROM ' || C_TABLE_OWNER || '.' || C_TABLE_NAME || ' ' ||
             'WHERE  patch_name = :b_patch_name '                   ||
             'AND    status = ''APPLIED''';


    ------------------------------------------
    -- Recorro el cursor de parches aplicados
    ------------------------------------------
    OPEN c_patches FOR l_stm USING l_patch_name;
    LOOP
        FETCH c_patches INTO r_patch;
        EXIT WHEN c_patches%NOTFOUND;

        -----------------------------------------------------------
        -- En principio, inicializo la variable auxiliar indicando
        -- que el prerequisito existe
        -----------------------------------------------------------
        l_prereq_found := TRUE;

        ----------------------------------
        -- Verifico si el idioma coincide
        ----------------------------------
        IF (l_patch_language IS NOT NULL) THEN
            IF (r_patch.patch_language IS NULL) THEN
                l_prereq_found := FALSE;
            ELSIF (r_patch.patch_language != l_patch_language) THEN
                l_prereq_found := FALSE;
            END IF;
        END IF;

        ------------------------------------
        -- Verifico si el servidor coincide
        ------------------------------------
        IF (l_patch_server IS NOT NULL) THEN
            IF (r_patch.patch_server IS NULL) THEN
                l_prereq_found := FALSE;
            ELSIF (r_patch.patch_server != l_patch_server) THEN
                l_prereq_found := FALSE;
            END IF;
        END IF;

        ---------------------------------------------------
        -- Verifico si la version coincide (o es superior)
        ---------------------------------------------------
        IF (l_patch_release IS NOT NULL) THEN
            IF (r_patch.patch_release IS NULL) THEN
                l_prereq_found := FALSE;
            ELSIF (r_patch.patch_release != l_patch_release) THEN
                SELECT lpad(r_patch.patch_release,
                            decode(instr(r_patch.patch_release, '.', 1), 0,
                                   C_MAX_REL_SIZE,
                                   C_MAX_REL_SIZE +
                                     length(r_patch.patch_release) -
                                     instr(r_patch.patch_release, '.', 1) +
                                     1),
                            ' ') rel1,
                       lpad(l_patch_release,
                            decode(instr(l_patch_release, '.', 1), 0,
                                   C_MAX_REL_SIZE,
                                   C_MAX_REL_SIZE +
                                     length(l_patch_release) -
                                     instr(l_patch_release, '.', 1) +
                                     1),
                            ' ') rel2
                INTO l_rel1, l_rel2
                FROM dual;
                IF (l_rel1 < l_rel2) THEN
                    l_prereq_found := FALSE;
                END IF;
            END IF;
        END IF;

        IF (l_prereq_found) THEN
            EXIT;
        END IF;

    END LOOP;
    CLOSE c_patches;

 
    -------------------------------------------------
    -- Devuelvo el codigo de retorno que corresponda
    -- A la inversa del Pre-Requisito, aca pregunto 
    -- Si ya fue instalado 
    -------------------------------------------------
    IF (l_prereq_found) THEN
        :v_return_status := C_EXIT_CODE_ERROR;
    ELSE
        :v_return_status := C_EXIT_CODE_OK;
    END IF;

EXCEPTION
    WHEN others THEN
        :v_return_status := C_EXIT_CODE_ERROR;
END;
/

EXIT :v_return_status;

END_OF_SQL\");


if ( ! \$l_result ) {
   \$TEXT_LINE=\"Parche no instalado anteriormente\";
    PrintLine();
   \$TEXT_LINE=\" \";
    PrintLine();
} else {
    \$CONFIRM_PREREQ=\"N\";
    \$TEXT_LINE=\"WARNING: El parche fue instalado previamente\";
    PrintLine();
    \$TEXT_LINE=\" # Patch    : \$PATCH_PATCH\";
    PrintLine();
    \$TEXT_LINE=\" # Release  : \$PATCH_RELEASE\";
    PrintLine();
    \$TEXT_LINE=\" # Server   : \$PATCH_SERVER\";
    PrintLine();
    \$TEXT_LINE=\" # Language : \$PATCH_LANGUAGE\";
    PrintLine();
    \$TEXT_LINE=\" \";
    PrintLine();
    \$TEXT_LINE=\"Desea continuar de todas formas con la aplicacion del parche (y/n)?\";
    PrintLine();
    \$CONFIRM_PREREQ = <STDIN>;
    chomp \$CONFIRM_PREREQ ;

    if ( \"\$CONFIRM_PREREQ\" ne \"Y\" && \"\$CONFIRM_PREREQ\" ne \"y\" ) {
        \$TEXT_LINE=\"Aplicacion del parche abortada.\";
        PrintLine();
        \$PATCH_STATUS=\"PREREQ_FAILED\";
        UpdatePatchLog();
        exit \$EXIT_CODE_ERROR;
    } else {
        \$TEXT_LINE=\" \";
        PrintLine();
    }
}

return \$EXIT_CODE_OK;

} \n";


# ------------------------------------------------------------------------
# INICIO DE LA GENERACION DEL METASCRIPT CON LOS COMANDOS DE EJECUCION
# En primer lugar, genero  el encabezado del metascript
# ------------------------------------------------------------------------

#
# Genero el encabezado del script a procesar
#
print TMPFH "
#-------------------------------------------------------------------------#
#                                                                         #
#                  P R O G R A M A     P R I N C I P A L                  #
#                                                                         #
#-------------------------------------------------------------------------#

#--------------------------------------------
# Definiendo variables para el procesamiento
#--------------------------------------------

\$DRIVERFILE=\"$DRIVERFILE\";
\$LOGFILE=\"$LOGFILE\";
\$TMP_DIR=\"$TMP_DIR\";
\$BACKUP_FLAG=\"$BACKUP_FLAG\";
\$EXIT_CODE_OK=\"$EXIT_CODE_OK\";
\$EXIT_CODE_ERROR=\"$EXIT_CODE_ERROR\";
\$DEFAULT_DB_USER=\"$DEFAULT_DB_USER\";
\$DEFAULT_DB_PWD=\"$DEFAULT_DB_PWD\";
\$DEFAULT_LOG_TABLE_NAME=\"$DEFAULT_LOG_TABLE_NAME\";
\$TOTAL_PATCH_ERRORS=\"0\";
\%XX_LIST_OF_REAL_USERS=\(\);
\%XX_LIST_OF_PASSWORDS=\(\);


if ( ! -f \$LOGFILE ) {
    open (LOGFH, \">\$LOGFILE\") || die \"ERROR: No se pudo crear el archivo de log\\n Archivo Log: \$LOGFILE\\n\";
} else {
    open (LOGFH, \">>\$LOGFILE\") || die \"ERROR: No se pudo crear el archivo de log\\n Archivo Log: \$LOGFILE\\n\";
}

#----------------------------------------------
# Definiendo variables para usuarios virtuales
#----------------------------------------------
";

foreach $username (keys %LIST_OF_VIRTUAL_USERS) {
    if ($LIST_OF_VIRTUAL_USERS{$username}) {
       print TMPFH " \$XX_LIST_OF_REAL_USERS{\"$username\"}=\"$LIST_OF_VIRTUAL_USERS{$username}\"; \n";
    } else {
       print TMPFH " \$XX_LIST_OF_REAL_USERS{\"$username\"}=\"$username\"; \n";
    }
}

# ------------------------------------------------------------------------
# Hago una primer pasada del driver para identificar los usuarios de la
# base de datos con los cuales se tendra que conectar. Se generan los
# comandos para solicitar las passwords y validarlas.
# Tambien valido si hay que solicitar &Thin_DB_Connection
# ------------------------------------------------------------------------

               #
               # Inicializo variables
               #
               $thin_connection_required="N";
               $default_user_required="N";
               $beginend_conn_within="N";
               $beginend_log_info_exists="N";

   $NR = 0;
   open (DF, $DRIVERFILE) || die "Error al abrir el archivo $DRIVERFILE\n";
   while (defined ($line = <DF>)) {
      chomp ($line);
      # Eliminar Blancos al principio de la linea
      $line=~s/^ *//;

      # dividir la linea en campos de un vector separador=" "
      @vline = split /\s+/ , $line;
      $NF = @vline;
      $NR++;

      if ($NF) {
               #
               # Proceso cada linea del driver
               #
               if ($vline[0] eq "begin" && $vline[1] eq "connection") {
                   $beginend_conn_within="Y";

		   if ( ! $vline[3]) {
                       $vline[2]=~tr/a-z/A-Z/;
                       $XX_LIST_OF_DB_USERS{$vline[2]}="";
                   } elsif ( $vline[3] eq "virtual") {

                       $vline[2]=~tr/a-z/A-Z/;
                       $XX_LIST_OF_DB_USERS{$vline[2]}=$vline[3];
                   }
               }
               if ($vline[0] eq "end" && $vline[1] eq "connection") {
                   $beginend_conn_within="N";
               }
               if ($vline[0] eq "begin" && $vline[1] eq "log_info") {
                   $beginend_log_info_exists="Y";
               }
               if ($beginend_conn_within eq "N") {
                   if ($vline[0] eq "mergepll" ||
                       $vline[0] eq "purgepll" ||
                       $vline[0] eq "sql" ||
                       $vline[0] eq "genform" ||
                       $vline[0] eq "genfpll" ||
                       $vline[0] eq "table" ||
                      ($vline[0] eq "begin" && $vline[1] eq "log_info") ||
                      ($vline[0] eq "end" && $vline[1] eq "log_info")) {
                       $default_user_required="Y";
                   }
               }
               # Valido si es necesario solicitar thin connection

               if ( $line =~ /.&db_host./i  ||
                    $line =~ /.&db_port./i  ||
                    $line =~ /.&db_name./i 
                  ) {

                       $thin_connection_required="Y";
               }
         }
     }

     close (DF);
               #
               # Determino si es necesario tambien incluir el usuario por defecto
               #
               if ($default_user_required eq "Y" ||
                   $beginend_log_info_exists eq "N") {
                   $DEFAULT_DB_USER=~tr/a-z/A-Z/;
                   $XX_LIST_OF_DB_USERS{$DEFAULT_DB_USER}="";

               }


print TMPFH "
 #--------------------------------------------
 # Verificando conexiones de los usuarios
 #--------------------------------------------
 \$TEXT_LINE=\" \";
 PrintLine();
 \$TEXT_LINE=\"######################################################### \";
 PrintLine();
 \$TEXT_LINE=\"### Verificando conexion de usuarios de base de datos ### \";
 PrintLine();
 \$TEXT_LINE=\"######################################################### \";
 PrintLine();
 \$TEXT_LINE=\" \";
 PrintLine();
";

foreach $username (keys %XX_LIST_OF_DB_USERS) {
 print TMPFH "
  #--------------------------------------------
  # Verifico conexion del usuario $username
  #--------------------------------------------

 ";

  if ($XX_LIST_OF_DB_USERS{$username} eq "virtual") {
    print TMPFH "  if ( ! \$XX_LIST_OF_REAL_USERS{\"$username\"} ) {\n";
    print TMPFH "     \$REQUEST_USER=\"Y\";\n";
    print TMPFH "     \$DBUSER=\"$username\";\n";
    print TMPFH "  } else {\n";
    print TMPFH "     \$REQUEST_USER=\"N\";\n";
    print TMPFH "     \$DBUSER=\$XX_LIST_OF_REAL_USERS{\"$username\"};\n";
    print TMPFH "  }\n";
  } else  {
    print TMPFH "  \$REQUEST_USER=\"N\";\n";
    print TMPFH "  \$DBUSER=\"$username\";\n";
  }
  if ($username eq $DEFAULT_DB_USER && $XX_LIST_OF_DB_USERS{$username} ne "virtual") {
    print TMPFH "  \$DBPASSWORD=\"$DEFAULT_DB_PWD\";\n";
  } else {
    print TMPFH "  \$DBPASSWORD=\"\";\n";
  }
  print TMPFH "  \$l_result = CheckDBConnection();\n";
  print TMPFH "  if ( \$l_result ) {\n";
  print TMPFH "     exit \$EXIT_CODE_ERROR;\n";
  print TMPFH "  }\n";
  print TMPFH "  \$XX_LIST_OF_PASSWORDS{\$DBUSER}=\$DBPASSWORD\;\n";

  if ($username eq $DEFAULT_DB_USER && $XX_LIST_OF_DB_USERS{$username} ne "virtual") {
       print TMPFH "  \$DEFAULT_DB_PWD=\$DBPASSWORD\;\n";
  }
  print TMPFH " ";
  print TMPFH " ";
}

if ($thin_connection_required eq "Y" ) {

   

  print TMPFH "  \$l_result = CheckDBThinConnection();\n";
  print TMPFH "  if ( \$l_result ) {\n";
  print TMPFH "     exit \$EXIT_CODE_ERROR;\n";
  print TMPFH "  }\n";

}   

#
# Inicializacion de variables
#
$current_db_user=$DEFAULT_DB_USER;
$beginend_log_info_within="N";
$beginend_log_info_exists="N";

#
# Impresion del encabezado
#
print TMPFH " \n";
print TMPFH " \n";
print TMPFH "#---------------------------------------------\n";
print TMPFH "# Definiendo informacion para log del proceso\n";
print TMPFH "#---------------------------------------------\n";

$NR = 0;
open (DF, $DRIVERFILE) || die "Error al abrir el archivo $DRIVERFILE\n";
while (defined ($line = <DF>)) {
      chomp ($line);
      # Eliminar Blancos al principio de la linea
      $line=~s/^ *//;

      # dividir la linea en campos de un vector separador=" "
      @vline = split /\s+/ , $line;
      $NF = @vline;
      $NR++;

      if ($NF) {

          if ($vline[0] eq "begin" && $vline[1] eq "connection") {
                   $current_db_user=$vline[2];
                   $current_db_user=~ tr/a-z/A-Z/;
          }
          if ($vline[0] eq "end" && $vline[1] eq "connection") {
                   $current_db_user=$DEFAULT_DB_USER;
          }
          if ($vline[0] eq "begin" && $vline[1] eq "log_info") {
             $beginend_log_info_within="Y";
             $beginend_log_info_exists="Y";

             print TMPFH "\$XXDBLOG_TABLE_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}\n";
             print TMPFH "\$XXDBLOG_TABLE_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";
          }
          if ($vline[0] eq "end" && $vline[1] eq "log_info") {
                   $beginend_log_info_within="N";
          }
          if ($vline[0] eq "table" && $beginend_log_info_within eq "Y") {
                   print TMPFH "\$XXDBLOG_TABLE_NAME=\$vline[1];\n";
          }
     }
}

close (DF);

if ($beginend_log_info_exists eq "N") {
   print TMPFH "\$XXDBLOG_TABLE_DB_USR=\$DEFAULT_DB_USER;\n";
   print TMPFH "\$XXDBLOG_TABLE_DB_PWD=\$DEFAULT_DB_PWD;\n";
   print TMPFH "\$XXDBLOG_TABLE_NAME=\$DEFAULT_LOG_TABLE_NAME;\n";
}
print TMPFH " \n";
print TMPFH " \n";





# ------------------------------------------------------------------------
# Hago una tercera pasada del driver para generar los logs del proceso
# ------------------------------------------------------------------------
#
# Inicializacion de variables
#
$beginend_patch_count="0";
$beginend_patch_info_within="N";
#
# Genero el encabezado del script a procesar
#
print TMPFH "
 #--------------------------------------------
 # Verifico que exista la tabla de log
 #--------------------------------------------
 \$TEXT_LINE=\" \";
 PrintLine();
 \$TEXT_LINE=\"######################################################### \";
 PrintLine();
 \$TEXT_LINE=\"### Inicializando entorno para instalacion del parche ###\";
 PrintLine();
 \$TEXT_LINE=\"######################################################### \";
 PrintLine();
 \$TEXT_LINE=\" \";
 PrintLine();
 CheckLogTable();

";


$NR = 0;
open (DF, $DRIVERFILE) || die "Error al abrir el archivo $DRIVERFILE\n";
while (defined ($line = <DF>)) {
      chomp ($line);
      # Eliminar Blancos al principio de la linea
      $line=~s/^ *//;

      # dividir la linea en campos de un vector separador=" "
      @vline = split /\s+/ , $line;
      $NF = @vline;
      $NR++;

      if ($NF) {

         if ($vline[0] eq "begin" && $vline[1] eq "patch") {
                   $beginend_patch_count++;
                   print TMPFH "#--------------------------------------------\n";
                   print TMPFH "# Genero el log del proceso para parche $vline[2]\n";
                   print TMPFH "#--------------------------------------------\n";
                   print TMPFH "\$PATCH_NAME=\"$vline[2]\";\n";
                   print TMPFH "\$PATCH_RELEASE=\"\";\n";
                   print TMPFH "\$PATCH_SERVER=\"\";\n";
                   print TMPFH "\$PATCH_LANGUAGE=\"\";\n";
         }
         if ($vline[0] eq "begin" && $vline[1] eq "patch_info") {
                   $beginend_patch_info_within="Y";
         }
         if ($vline[0] eq "end" && $vline[1] eq "patch_info") {
                   $beginend_patch_info_within="N";
         }
         if ($vline[0] eq "release" && $beginend_patch_info_within eq "Y") {
                   print TMPFH "\$PATCH_RELEASE=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "server" && $beginend_patch_info_within eq "Y") {
                   print TMPFH "\$PATCH_SERVER=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "language" && $beginend_patch_info_within eq "Y") {
                      print TMPFH "\$PATCH_LANGUAGE=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "end" && $vline[1] eq "patch") {
                   print TMPFH "LogProcess();\n";
                   print TMPFH " \n";
                   print TMPFH " \n";
         }
      }
  }

close (DF);

if ($beginend_patch_count <= 0) {
 print TMPFH "

 #--------------------------------------------
 # Genero el log del proceso para el parche
 #--------------------------------------------
 \$PATCH_NAME=\"NONE\";
 \$PATCH_RELEASE=\"\";
 \$PATCH_SERVER=\"\";
 \$PATCH_LANGUAGE=\"\";
 LogProcess();

";
}





# ------------------------------------------------------------------------
# Hago una cuarta pasada del driver para chequear prerequisitos
# ------------------------------------------------------------------------
$beginend_prereq_within="N";
$any_prereq_flag="N";
print TMPFH "\$TEXT_LINE=\" \";\n";
print TMPFH "PrintLine();";
print TMPFH "\$TEXT_LINE=\" \";\n";
print TMPFH "PrintLine();\n";
print TMPFH "\$TEXT_LINE=\"######################################################### \";\n";
print TMPFH "PrintLine();\n";
print TMPFH "\$TEXT_LINE=\"### Verificando los prerequisitos para la instalacion ###\";\n";
print TMPFH "PrintLine();\n";
print TMPFH "\$TEXT_LINE=\"######################################################### \";\n";
print TMPFH "PrintLine();\n";
print TMPFH "\$TEXT_LINE=\" \";\n";
print TMPFH "PrintLine();\n";

$NR = 0;
open (DF, $DRIVERFILE) || die "Error al abrir el archivo $DRIVERFILE\n";
while (defined ($line = <DF>)) {
      chomp ($line);
      # Eliminar Blancos al principio de la linea
      $line=~s/^ *//;

      # dividir la linea en campos de un vector separador=" "
      @vline = split /\s+/ , $line;
      $NF = @vline;
      $NR++;

      if ($NF) {

         if ($vline[0] eq "begin" && $vline[1] eq "prereq") {
                   $beginend_prereq_within="Y";
                   $any_prereq_flag="Y";
                   print TMPFH "#--------------------------------------------\n";
                   print TMPFH "# Verifico prerequisito $vline[2]\n";
                   print TMPFH "#--------------------------------------------\n";
                   print TMPFH "\$PREREQ_PATCH=\"$vline[2]\";\n";
                   print TMPFH "\$PREREQ_RELEASE=\"\";\n";
                   print TMPFH "\$PREREQ_SERVER=\"\";\n";
                   print TMPFH "\$PREREQ_LANGUAGE=\"\";\n";
         }
         if ($vline[0] eq "release" && $beginend_prereq_within eq "Y") {
                   print TMPFH "\$PREREQ_RELEASE=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "server" && $beginend_prereq_within eq "Y") {
                   print TMPFH "\$PREREQ_SERVER=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "language" && $beginend_prereq_within eq "Y") {
                      print TMPFH "\$PREREQ_LANGUAGE=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "end" && $vline[1] eq "prereq") {
                      $beginend_prereq_within="N";
                      print TMPFH "CheckPrereq();\n";
                      print TMPFH " \n";
                      print TMPFH " \n";
         }
      }
}

close (DF);

if ($any_prereq_flag eq "N") {
     print TMPFH "\$TEXT_LINE=\"No hay prerequisitos para verificar.\";\n";
     print TMPFH "PrintLine();\n";
     print TMPFH "\$TEXT_LINE=\" \";\n";
     print TMPFH "PrintLine();\n";
}





# FBarros 20-MAR-2010
# --------------------------------------------------------------------------------
# Hago una quinta pasada del driver para chequear si la version ya fue instalada
# --------------------------------------------------------------------------------
$beginend_prereq_within="N";
$any_version_flag="N";
print TMPFH "\$TEXT_LINE=\" \";\n";
print TMPFH "PrintLine();";
print TMPFH "\$TEXT_LINE=\" \";\n";
print TMPFH "PrintLine();\n";
print TMPFH "\$TEXT_LINE=\"######################################################### \";\n";
print TMPFH "PrintLine();\n";
print TMPFH "\$TEXT_LINE=\"### Verificando datos del parche para la instalacion ###\";\n";
print TMPFH "PrintLine();\n";
print TMPFH "\$TEXT_LINE=\"######################################################### \";\n";
print TMPFH "PrintLine();\n";
print TMPFH "\$TEXT_LINE=\" \";\n";
print TMPFH "PrintLine();\n";

$NR = 0;
open (DF, $DRIVERFILE) || die "Error al abrir el archivo $DRIVERFILE\n";
while (defined ($line = <DF>)) {
      chomp ($line);
      # Eliminar Blancos al principio de la linea
      $line=~s/^ *//;

      # dividir la linea en campos de un vector separador=" "
      @vline = split /\s+/ , $line;
      $NF = @vline;
      $NR++;

      if ($NF) {

         if ($vline[0] eq "begin" && $vline[1] eq "patch") {
                   $beginend_patch_within="Y";
                   print TMPFH "#--------------------------------------------\n";
                   print TMPFH "# Verifico prerequisito $vline[2]\n";
                   print TMPFH "#--------------------------------------------\n";
                   print TMPFH "\$PATCH_PATCH=\"$vline[2]\";\n";

         }

         if ($vline[0] eq "begin" && $vline[1] eq "patch_info") {
                   $beginend_patch_ver_within="Y";
                   $any_version_flag="Y";
                   print TMPFH "\$PATCH_RELEASE=\"\";\n";
                   print TMPFH "\$PATCH_SERVER=\"\";\n";
                   print TMPFH "\$PATCH_LANGUAGE=\"\";\n";
         }
         if ($vline[0] eq "release" && $beginend_patch_ver_within eq "Y") {
                   print TMPFH "\$PATCH_RELEASE=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "server" && $beginend_patch_ver_within eq "Y") {
                   print TMPFH "\$PATCH_SERVER=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "language" && $beginend_patch_ver_within eq "Y") {
                      print TMPFH "\$PATCH_LANGUAGE=\"$vline[1]\";\n";
         }
         if ($vline[0] eq "end" && $vline[1] eq "patch_info") {
                      $beginend_patch_ver_within="N";
                      print TMPFH "CheckPatchVersion();\n";
                      print TMPFH " \n";
                      print TMPFH " \n";
         }
         if ($vline[0] eq "end" && $vline[1] eq "patch") {
                      $beginend_patch_within="N";
         }
      }
}

close (DF);

if ($any_version_flag eq "N") {
     print TMPFH "\$TEXT_LINE=\"No hay version para verificar.\";\n";
     print TMPFH "PrintLine();\n";
     print TMPFH "\$TEXT_LINE=\" \";\n";
     print TMPFH "PrintLine();\n";
}
# Fin FBarros 20-MAR-2010




# ------------------------------------------------------------------------
# Finalmente, hago una ultima pasada para generar los comandos reales,
# correspondientes a las acciones del driver
# ------------------------------------------------------------------------

#
# Inicializacion de variables
#
$current_db_user=$DEFAULT_DB_USER;
$commands_total=0;

#
# Impresion del encabezado
#
print TMPFH "
 #--------------------------------------------
 # Inicio del procesamiento
 #--------------------------------------------
 \$TEXT_LINE=\" \";
 PrintLine();
 \$TEXT_LINE=\" \";
 PrintLine();
 \$TEXT_LINE=\"#########################################################\";
 PrintLine();
 \$TEXT_LINE=\"### Inicio de la ejecucion de los comandos del driver ###\";
 PrintLine();
 \$TEXT_LINE=\"#########################################################\";
 PrintLine();
 \$TEXT_LINE=\" \";
 PrintLine();
 \$TEXT_LINE=\" \";
 PrintLine();
";


$NR = 0;
open (DF, $DRIVERFILE) || die "Error al abrir el archivo $DRIVERFILE\n";
while (defined ($line = <DF>)) {
      chomp ($line);
      # Eliminar Blancos al principio de la linea
      $line=~s/^ *//;

      # dividir la linea en campos de un vector separador=" "
      @vline = split /\s+/ , $line;
      $NF = @vline;
      $NR++;

      if ($NF) {

               if ($vline[0] eq "begin" && $vline[1] eq "connection") {
                   $current_db_user=$vline[2];
                   $current_db_user =~ tr/a-z/A-Z/;
               }
               if ($vline[0] eq "end" && $vline[1] eq "connection") {
                   $current_db_user=$DEFAULT_DB_USER;
                   $current_db_user =~ tr/a-z/A-Z/;
               }
               if ($vline[0] eq "copy") {
                   $commands_total++;

                   print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                   print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";
                   print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                   $vline[1] =~ tr/A-Z/a-z/;
                   print TMPFH "\$SOURCE_DIR=\"$vline[1]/$vline[2]\";\n";
                   $vline[1] =~ tr/a-z/A-Z/;
                   if (! $ENV{$vline[1]."_TOP"}) {
                      print TMPFH "\$TARGET_DIR=\"/$vline[2]\";\n";
                   } else {
                      print TMPFH "\$TARGET_DIR=\$ENV{\"$vline[1]_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   print TMPFH "\$l_result = CopyFile();\n";
                   print TMPFH "if (\$l_result) { \n";
                   print TMPFH "    \$PATCH_ERRORS=1;\n";
                   print TMPFH "    LogPatchError();\n";
                   print TMPFH "}\n";
                   print TMPFH " \n";
                   if (substr($vline[3], length($vline[3])-2) eq "fmb") {
                       $vline[1] =~ tr/a-z/A-Z/;
                       if ($vline[1] ne "AU") {
                           print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                           print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";
                           print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                           $vline[1] =~ tr/A-Z/a-z/;
                           print TMPFH "\$SOURCE_DIR=\"$vline[1]/$vline[2]\";\n";
                           if (! $ENV{"AU_TOP"}) {
                              print TMPFH "\$TARGET_DIR=\"/$vline[2]\";\n";
                           } else {
                              print TMPFH "\$TARGET_DIR=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                           }
                           print TMPFH "\$l_result = CopyFile();\n";
                           print TMPFH "if (\$l_result) { \n";
                           print TMPFH "    \$PATCH_ERRORS=1;\n";
                           print TMPFH "    LogPatchError();\n";
                           print TMPFH "}\n";
                           print TMPFH " \n";
                       }
                   }
                   if (substr($vline[3], length($vline[3])-2) eq "pll") {
                       $vline[1] =~ tr/a-z/A-Z/;
                       if ($vline[1] ne "AU") {
                           print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                           print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";

                           print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                           $vline[1] =~ tr/A-Z/a-z/;
                           print TMPFH "\$SOURCE_DIR=\"$vline[1]/$vline[2]\";\n";
                           if (! $ENV{"AU_TOP"}) {
                              print TMPFH "\$TARGET_DIR=\"/$vline[2]\";\n";
                           } else {
                              print TMPFH "\$TARGET_DIR=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                           }
                           print TMPFH "\$l_result = CopyFile();\n";
                           print TMPFH "if (\$l_result) { \n";
                           print TMPFH "    \$PATCH_ERRORS=1;\n";
                           print TMPFH "    LogPatchError();\n";
                           print TMPFH "}\n";
                           print TMPFH " \n";
                       }
                   }
               }
               if ($vline[0] eq "mergepll") {
                   $commands_total++;
                   if (substr($vline[3], length($vline[3])-3) eq "pll") {
                      print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                      print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";
                       print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                       $vline[1] =~ tr/A-Z/a-z/;
                       print TMPFH "\$SOURCE_DIR=\"$vline[1]/$vline[2]\";\n";
                       if (! $ENV{"AU_TOP"}) {
                          print TMPFH "\$TARGET_DIR1=\"/$vline[2]\";\n";
                       } else {
                          print TMPFH "\$TARGET_DIR1=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                       }
                       $vline[1] =~ tr/a-z/A-Z/;
                       if (! $ENV{$vline[1]."_TOP"}) {
                           print TMPFH "\$TARGET_DIR2=\"/$vline[2]\";\n";
                       } else {
                           print TMPFH "\$TARGET_DIR2=\$ENV{\"$vline[1]_TOP\"}\.\"/$vline[2]\";\n";
                       }
                       if (substr($vline[4], length($vline[4])-3) eq "pll") {
                           print TMPFH "\$TARGET_FILE=\"$vline[4]\";\n";
                           if ($vline[5]) {
                               print TMPFH "\$MERGEOPTIONS=\"-h $vline[5]\";\n";
                           }
                           else {
                               print TMPFH "\$MERGEOPTIONS=\" \";\n";
                           }
                       }
                       else {
                           print TMPFH "\$TARGET_FILE=\"$vline[3]\";\n";
                           if ($vline[4] ne "") {
                               print TMPFH "\$MERGEOPTIONS=\"-h $vline[4]\";\n";
                           }
                           else {
                               print TMPFH "\$MERGEOPTIONS=\" \";\n";
                           }
                       }
                       print TMPFH "\$l_result = MergeLibrary();\n";
                       print TMPFH "if (\$l_result) { \n";
                       print TMPFH "    \$PATCH_ERRORS=1;\n";
                       print TMPFH "    LogPatchError();\n";
                       print TMPFH "}\n";
                       print TMPFH " \n";
                   }
                   else {
                      print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                      print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";

                       print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                       $vline[1] =~ tr/A-Z/a-z/;
                       print TMPFH "\$SOURCE_DIR=\"$vline[1]/$vline[2]\";\n";
                       $vline[1] =~ tr/a-z/A-Z/;
                       if (! $ENV{$vline[1]."_TOP"}) {
                           print TMPFH "\$TARGET_DIR=\"/$vline[2]\";\n";
                       } else {
                           print TMPFH "\$TARGET_DIR=\$ENV{\"$vline[1]_TOP\"}\.\"/$vline[2]\";\n";
                       }
                       print TMPFH "\$l_result = CopyFile();\n";
                       print TMPFH "if (\$l_result) {\n";
                       print TMPFH "    \$PATCH_ERRORS=1;\n";
                       print TMPFH "    LogPatchError();\n";
                       print TMPFH "}\n";
                       print TMPFH " \n";
                       if (substr($vline[3], length($vline[3])-3) eq "fmb") {
                           $vline[1] =~ tr/a-z/A-Z/;
                           if ($vline[1] ne "AU") {
                            print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                            print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";

                               print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                               $vline[1] =~ tr/A-Z/a-z/;
                               print TMPFH "\$SOURCE_DIR=\"$vline[1]/$vline[2]\";\n";
                               if (! $ENV{"AU_TOP"}) {
                                  print TMPFH "\$TARGET_DIR1=\"/$vline[2]\";\n";
                               } else {
                                  print TMPFH "\$TARGET_DIR=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                               }
                               print TMPFH "\$l_result = CopyFile();\n";
                               print TMPFH "if (\$l_result) {\n";
                               print TMPFH "    \$PATCH_ERRORS=1;\n";
                               print TMPFH "    LogPatchError();\n";
                               print TMPFH "}\n";
                               print TMPFH " \n";
                           }
                       }
                   }
               }
               if ($vline[0] eq "purgepll") {
                   $commands_total++;
                   print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                   print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";

                   print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                   if (! $ENV{"AU_TOP"}) {
                          print TMPFH "\$TARGET_DIR1=\"/$vline[2]\";\n";
                   } else {
                          print TMPFH "\$SOURCE_DIR=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   if (! $ENV{"AU_TOP"}) {
                          print TMPFH "\$TARGET_DIR1=\"/$vline[2]\";\n";
                   } else {
                          print TMPFH "\$TARGET_DIR1=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   $vline[1] =~ tr/a-z/A-Z/;
                   if (! $ENV{$vline[1]."_TOP"}) {
                      print TMPFH "\$TARGET_DIR2=\"/$vline[2]\";\n";
                   } else {
                      print TMPFH "\$TARGET_DIR2=\$ENV{\"$vline[1]_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   if ($vline[5]) {
                       print TMPFH "\$MERGEOPTIONS=\"-p $vline[4] -h $vline[5]\";\n";
                   }
                   else {
                       print TMPFH "\$MERGEOPTIONS=\"-p $vline[4]\";\n";
                   }
                   print TMPFH "\$l_result = PurgeLibrary();\n";
                   print TMPFH "if (\$l_result) {\n";
                   print TMPFH "    \$PATCH_ERRORS=1;\n";
                   print TMPFH "    LogPatchError();\n";
                   print TMPFH "}\n";
                   print TMPFH " \n";
               }
               if ($vline[0] eq "sql") {
                   $commands_total++;
                   print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                   print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";

                   print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                   $vline[1] =~ tr/a-z/A-Z/;
                   if (! $ENV{$vline[1]."_TOP"}) {
                      print TMPFH "\$SOURCE_DIR=\"/$vline[2]\";\n";
                   } else {
                      print TMPFH "\$SOURCE_DIR=\$ENV{\"$vline[1]_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   print TMPFH "\$l_result = ExecuteSQL();\n";
                   print TMPFH "if (\$l_result) {\n";
                   print TMPFH "    \$PATCH_ERRORS=1;\n";
                   print TMPFH "    LogPatchError();\n";
                   print TMPFH "}\n";
                   print TMPFH " \n";
               }
               
               # java execution upload
               if ($vline[0] eq "java") {
                   $commands_total++;

                   print TMPFH "\$SOURCE_FILE=\"$vline[1]\";\n";

                   $param=$vline[2];
                   foreach ($i=3; $i<=$NF-1; $i++) {
                          $param=$param . " " . $vline[$i];
                   }
                   if ($param) {
                      print TMPFH "\$PARAMETERS=\'$param\';\n";
                   } else {
                      print TMPFH "\$PARAMETERS=\'\';\n";
                   }
                   print TMPFH "\$l_result = ExecuteJava();\n";
                   print TMPFH "if (\$l_result) {\n";
                   print TMPFH "    \$PATCH_ERRORS=1;\n";
                   print TMPFH "    LogPatchError();\n";
                   print TMPFH "}\n";
                   print TMPFH " \n";
               }
               if ($vline[0] eq "exec") {
                   $commands_total++;
                   print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                   print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";

                   print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                   $vline[1] =~ tr/a-z/A-Z/;
                   if (! $ENV{$vline[1]."_TOP"}) {
                      print TMPFH "\$SOURCE_DIR=\"/$vline[2]\";\n";
                   } else {
                      print TMPFH "\$SOURCE_DIR=\$ENV{\"$vline[1]_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   $param=$vline[4];
                   foreach ($i=5; $i<=$NF-1; $i++) {
                          $param=$param . " " . $vline[$i];
                   }
                   if ($param) {
                      print TMPFH "\$PARAMETERS=\'$param\';\n";
                   } else {
                      print TMPFH "\$PARAMETERS=\'\';\n";
                   }
                   print TMPFH "\$l_result = ExecuteFile();\n";
                   print TMPFH "if (\$l_result) {\n";
                   print TMPFH "    \$PATCH_ERRORS=1;\n";
                   print TMPFH "    LogPatchError();\n";
                   print TMPFH "}\n";
                   print TMPFH " \n";
               }
               if ($vline[0] eq "genform") {
                   $commands_total++;
                   print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                   print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";

                   print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                   if (! $ENV{"AU_TOP"}) {
                          print TMPFH "\$TARGET_DIR1=\"/$vline[2]\";\n";
                   } else {
                          print TMPFH "\$SOURCE_DIR=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   $vline[1] =~ tr/a-z/A-Z/;
                   if (! $ENV{$vline[1]."_TOP"}) {
                      print TMPFH "\$TARGET_DIR=\"/$vline[2]\";\n";
                   } else {
                      print TMPFH "\$TARGET_DIR=\$ENV{\"$vline[1]_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   print TMPFH "\$l_result = GenerateForm();\n";
                   print TMPFH "if (\$l_result) {\n";
                   print TMPFH "    \$PATCH_ERRORS=1;\n";
                   print TMPFH "    LogPatchError();\n";
                   print TMPFH "}\n";
                   print TMPFH " \n";
               }
               if ($vline[0] eq "genfpll") {
                   $commands_total++;
                   print TMPFH "\$COMMAND_DB_USR=\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"};\n";
                   print TMPFH "\$COMMAND_DB_PWD=\$XX_LIST_OF_PASSWORDS{\$XX_LIST_OF_REAL_USERS{\"$current_db_user\"}};\n";

                   print TMPFH "\$SOURCE_FILE=\"$vline[3]\";\n";
                   if (! $ENV{"AU_TOP"}) {
                          print TMPFH "\$TARGET_DIR1=\"/$vline[2]\";\n";
                   } else {
                          print TMPFH "\$SOURCE_DIR=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   if (! $ENV{"AU_TOP"}) {
                          print TMPFH "\$TARGET_DIR1=\"/$vline[2]\";\n";
                   } else {
                          print TMPFH "\$TARGET_DIR=\$ENV{\"AU_TOP\"}\.\"/$vline[2]\";\n";
                   }
                   print TMPFH "\$l_result = GenerateLibrary();\n";
                   print TMPFH "if (\$l_result) {\n";
                   print TMPFH "    \$PATCH_ERRORS=1;\n";
                   print TMPFH "    LogPatchError();\n";
                   print TMPFH "}\n";
                   print TMPFH " \n";
               }
           }
}

close (DF);

print TMPFH "
#--------------------------------------------
# Fin del procesamiento
#--------------------------------------------
\$TEXT_LINE=\" \";
PrintLine();
\$TEXT_LINE=\" \";
PrintLine();
\$TEXT_LINE=\" \";
PrintLine();
\$TEXT_LINE=\"######################################################### \";
PrintLine();
\$TEXT_LINE=\"### Fin de las ejecuciones de los comandos del driver ###\";
PrintLine();
\$TEXT_LINE=\"######################################################### \";
PrintLine();
\$TEXT_LINE=\" \";
PrintLine();
\$TEXT_LINE=\" # Cantidad de Comandos Ejecutados: $commands_total \";
PrintLine();
\$TEXT_LINE=\" # Cantidad de Comandos con Error : \$TOTAL_PATCH_ERRORS\";
PrintLine();
\$TEXT_LINE=\" \";
PrintLine();
\$PATCH_STATUS=\"APPLIED\";
UpdatePatchLog();

\$TEXT_LINE=\" \";
PrintLine();
";




close (TMPFH);
# ------------------------------------------------------------------------
# Ejecuto el shell script creado anteriormente
# ------------------------------------------------------------------------
chmod 0777, "$TMPFILE.$$" ;
system ("$TMPFILE.$$");

system ("rm $TMPFILE.$$");




# ------------------------------------------------------------------------
# Imprimo fin en el log del proceso
# ------------------------------------------------------------------------
$PATCHENDDATE=`date`;
$line_print ="
--------------------------------------------------

 APLICACION DE PATCH FINALIZADA
 Archivo Driver : $DRIVERFILE
 Fecha Inicio   : $PATCHSTARTDATE
 Fecha Fin      : $PATCHENDDATE

--------------------------------------------------

 ";
print LOGFH "$line_print";
print "$line_print";
# ---------------------------------------------------------------------- #
#                                                                        #
#                     R U T I N A S    L O C A L E S                     #
#                                                                        #
# ---------------------------------------------------------------------- #

# --------------------------------------------------------------
#
# Routine    : ShowUsage
# Purpose    : Muestra la sintaxis de uso del shell script
# Parameters : PROGRAM_NAME: Nombre del shell script
#
# --------------------------------------------------------------

sub ShowUsage  {
   print " \n";
   print "Uso: $L_PROGRAM_NAME [<opciones>] <archivo driver>\n";
   print " \n";
   print "En donde <opciones> pueden ser:\n";
   print "  -h                      : Muestra la ayuda del programa\n";
   print "  -b                      : Indica que se deben respaldar los fuentes\n";
   print "  -B                      : Indica que no se deben respaldar los fuentes\n";
   print "  -l <archivo log>        : Archivo de log del proceso\n";
   print "  -t <dir. temporal>      : Directorio para archivos temporales\n";
   print "  -v <virtualuser=dbuser> : Define el nombre real de un usuario virtual\n";
   print " \n";
   print "Y los argumentos son:\n";
   print "  <archivo driver>    : Archivo tipo driver (drv) con acciones a ejecutar\n";
   print " \n";
}



